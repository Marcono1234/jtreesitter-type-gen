package marcono1234.jtreesitter.type_gen;

import java.util.Objects;
import java.util.Optional;

/**
 * Configuration related to a specific {@code node-types.json} file / language.
 *
 * @param rootNodeTypeName
 *      Name of the root node type. This is usually the first {@code rules} entry in the {@code grammar.js}
 *      file. If provided, additional code will be generated to go from a jtreesitter {@code Tree} to a
 *      'typed tree'.
 *      <p>Starting with tree-sitter 0.24.0 this information is available in the {@code node-types.json} file
 *      (as {@code "root": true}), and must not be specified using this parameter here.
 * @param languageProviderConfig
 *      Configuration for how the generated code can obtain a tree-sitter {@code Language} instance for the
 *      language represented by the {@code node-types.json} file. If provided, additional code will be,
 *      generated exposing for example numeric node and field IDs, and validating at runtime that the names
 *      in the {@code node-types.json} file actually match the loaded language.
 */
// Note: Have to adjust this once multiple root nodes (https://github.com/tree-sitter/tree-sitter/issues/870) or
//   root nodes selected at runtime (https://github.com/tree-sitter/tree-sitter/issues/711) will be possible
public record LanguageConfig(Optional<String> rootNodeTypeName, Optional<LanguageProviderConfig> languageProviderConfig) {
    public LanguageConfig {
        Objects.requireNonNull(rootNodeTypeName);
        Objects.requireNonNull(languageProviderConfig);
    }

    /**
     * Represents information about how the generated code can obtain a tree-sitter {@code Language} instance
     * for the language the {@code node-types.json} belongs to.
     */
    // Note: If in the future the numeric node and field IDs are stored in `node-types.json` (see
    // https://github.com/tree-sitter/tree-sitter/issues/1475) it might not be necessary anymore to obtain
    // a `Language` object; but might still be useful for `node-types.json` generated by older versions, and
    // by looking up IDs at runtime it also verifies that the type and field names match those of the loaded
    // language and that it is not out-of-sync with `node-types.json`
    public sealed interface LanguageProviderConfig {
        /**
         * The type which declares the field or method which provides the {@code Language} instance.
         */
        TypeName declaringType();

        /**
         * Public static field
         */
        record Field(TypeName declaringType, String fieldName) implements LanguageProviderConfig {
            public Field {
                Objects.requireNonNull(declaringType);
                Objects.requireNonNull(fieldName);
            }
        }

        /**
         * Public static no-args method
         */
        record Method(TypeName declaringType, String methodName) implements LanguageProviderConfig {
            public Method {
                Objects.requireNonNull(declaringType);
                Objects.requireNonNull(methodName);
            }
        }

        /**
         * Obtains a language provider config from a string representation:
         * <ul>
         *     <li>{@code org.example.MyClass#field}: {@link Field}
         *     <li>{@code org.example.MyClass#method()}: {@link Method}
         * </ul>
         */
        static LanguageProviderConfig fromString(String string) {
            int memberSeparatorIndex = string.indexOf('#');
            if (memberSeparatorIndex == -1) {
                throw new IllegalArgumentException("Does not contain member name separator '#'");
            }

            TypeName type = TypeName.fromQualifiedName(string.substring(0, memberSeparatorIndex));
            String memberName = string.substring(memberSeparatorIndex + 1);

            if (memberName.endsWith("()")) {
                memberName = memberName.substring(0, memberName.length() - "()".length());
                return new Method(type, memberName);
            } else if (memberName.contains("(") || memberName.contains(")")) {
                throw new IllegalArgumentException("Only no-args method is supported");
            } else {
                return new Field(type, memberName);
            }
        }
    }
}
