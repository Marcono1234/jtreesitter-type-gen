package marcono1234.jtreesitter.type_gen.internal.gen;

import com.palantir.javapoet.*;
import marcono1234.jtreesitter.type_gen.internal.gen.common_classes.NodeUtilsGenerator;
import marcono1234.jtreesitter.type_gen.internal.gen.common_classes.TypedNodeInterfaceGenerator;
import marcono1234.jtreesitter.type_gen.internal.gen.utils.*;
import marcono1234.jtreesitter.type_gen.internal.node_types_json.Type;
import org.jspecify.annotations.Nullable;

import javax.lang.model.element.Modifier;
import java.util.*;
import java.util.function.BooleanSupplier;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Supplier;

import static marcono1234.jtreesitter.type_gen.internal.gen.utils.CodeGenHelper.createInitializingConstructor;

/**
 * Type of a {@link GenChildren}.
 *
 * <p>Use {@link #create} to create instances.
 */
public sealed interface GenChildType {
    /**
     * Gets a supplier for the Java type name for this type.
     */
    Supplier<ClassName> getJavaTypeNameSupplier();

    /**
     * If this child type represents a single node type, returns that, otherwise returns {@code null}.
     */
    default @Nullable GenNodeType getRepresentedNodeType() {
        return null;
    }

    /**
     * Information about the token enum generated by the child type.
     *
     * @param tokenEnumClass
     *      name of the enum class which will be generated
     * @param tokenTypes
     *      unnamed tree-sitter node types representing the 'tokens' (each of which will have a token
     *      enum constant)
     */
    record TokenEnumInfo(ClassName tokenEnumClass, List<String> tokenTypes) {
    }

    /**
     * If this child type generates a token enum, returns information about it.
     * Otherwise returns {@code null}.
     */
    @Nullable TokenEnumInfo getTokenEnumInfo(CodeGenHelper codeGenHelper);

    /**
     * Generates code for converting jtreesitter {@code List<Node>} {@code childrenVar} to a
     * {@code List<T extends TypedNode>} and creates a local variable {@code resultVar} with the result.
     */
    void addConvertingCall(MethodSpec.Builder builder, CodeGenHelper codeGenHelper, String childrenVar, String resultVar);

    /**
     * Returns whether this child type generates a Java interface which directly or indirectly
     * refers to {@code type}. To avoid infinite recursion, already seen types are tracked in {@code seenTypes}.
     *
     * @see GenNodeType#refersToType(GenRegularNodeType, Set)
     */
    boolean refersToTypeThroughInterface(GenRegularNodeType type, Set<GenRegularNodeType> seenTypes);

    /**
     * @param childGetterName
     *      name of the getter method for obtaining this child type, generated in the class for the parent node type
     */
    List<TypeBuilderWithName> generateJavaTypes(CodeGenHelper codeGenHelper, String childGetterName);

    interface ChildTypeNameGenerator {
        String generateInterfaceName(List<String> allChildTypes);
        String generateTokenClassName(List<String> tokenTypesNames);
        String generateTokenTypeConstantName(String tokenType, int index);
    }

    interface ChildCustomMethodsProvider {
        List<CustomMethodData> createCustomMethods(List<String> allChildTypes);
    }

    static GenChildType create(
        GenRegularNodeType enclosingNodeType,
        List<Type> types,
        ChildTypeNameGenerator nameGenerator,
        TypeNameCreator typeNameCreator,
        NodeTypeLookup nodeTypeLookup,
        Consumer<GenJavaType> additionalTypedNodeSubtypeCollector,
        ChildCustomMethodsProvider customMethodsProvider
    ) {
        if (types.isEmpty()) {
            throw new IllegalArgumentException("Empty types");
        }

        List<String> nonNamedTypes = new ArrayList<>();
        List<Type> namedTypes = new ArrayList<>();
        for (var type : types) {
            if (type.named) {
                namedTypes.add(type);
            } else {
                nonNamedTypes.add(type.type);
            }
        }

        /*
         * The following cases are covered:
         * 1. Only single named type -> use it as child type
         * 2. Only unnamed types -> generate a Java class for them and use it as child type
         * 3. Only named types -> generate a common interface for them and use it as child type
         * 4. Named & unnamed types -> similar to 3, but also generate a class as in 2 and let it
         *                             implement the interface as well
         *
         * Cases 3 and 4 are actually the same code path below, which creates a `MultiChildType`.
         */

        if (nonNamedTypes.isEmpty() && namedTypes.size() == 1) {
            return new SingleChildType(nodeTypeLookup.getNodeType(namedTypes.getFirst().type));
        }

        UnnamedTokensChildType tokensChildType = null;
        if (!nonNamedTypes.isEmpty()) {
            // This is generated as Java class and not as interface, so there is no need to implement it as top-level
            // because there won't be cyclic inheritance
            BooleanSupplier mustBeTopLevel = () -> false;
            String javaName = nameGenerator.generateTokenClassName(nonNamedTypes);
            ClassName javaTypeName = typeNameCreator.createChildClassName(enclosingNodeType.getJavaTypeName(), javaName, mustBeTopLevel);

            SequencedMap<String, String> tokensToJavaConstants = new LinkedHashMap<>();
            for (int i = 0; i < nonNamedTypes.size(); i++) {
                String tokenType = nonNamedTypes.get(i);
                String constantName = nameGenerator.generateTokenTypeConstantName(tokenType, i);
                var existing = tokensToJavaConstants.put(tokenType, constantName);
                if (existing != null) {
                    throw new IllegalArgumentException("Duplicate non-named type '%s' for enclosing type '%s'".formatted(tokenType, enclosingNodeType.getTypeName()));
                }
            }

            tokensChildType = new UnnamedTokensChildType(enclosingNodeType, javaTypeName, tokensToJavaConstants);

            if (namedTypes.isEmpty()) {
                // Only add tokensChildType at this place, if `namedTypes.isEmpty()`; otherwise if it is part of MultiChildType,
                // then it will transitively implement the TypedNode interface
                additionalTypedNodeSubtypeCollector.accept(tokensChildType);

                return tokensChildType;
            }
        }

        List<String> namedTypesNames = namedTypes.stream().map(t -> t.type).toList();
        List<GenNodeType> genTypes = namedTypesNames.stream().map(nodeTypeLookup::getNodeType).toList();

        // Check if there is a direct or indirect reference back to the enclosing type,
        // for example `Node.Child -> Node` or `Node.Child -> Supertype -> Node`
        // In that case child type must be top-level; generating it as nested type leads to "cyclic inheritance" error
        BooleanSupplier mustBeTopLevel = () -> genTypes.contains(enclosingNodeType)
            // Also have to check indirect references, e.g. `Node.Child -> Supertype -> Node`; javac does not
            // permit this either when Child is a nested class
            || genTypes.stream().anyMatch(t -> t.refersToType(enclosingNodeType, new HashSet<>()));

        // Note: Uses `types` here (instead of `namedTypes`), which includes non-named types (if any) as well
        List<String> allTypesNames = types.stream().map(t -> t.type).toList();
        String javaName = nameGenerator.generateInterfaceName(allTypesNames);
        /*
         * Must use a Supplier here to delay creation of the type name, because `mustBeTopLevel` can only be evaluated once
         * children of referenced types have been populated
         *
         * This is not ideal but cannot be easily improved? Ideally type names are already available when creating code
         * structure, but `mustBeTopLevel` requires waiting until node types have already been created and their children have
         * been populated (alternative would be to perform name creation after code structure creation, but that would
         * require large refactoring, and would probably require making all classes stateful)
         */
        Supplier<ClassName> javaTypeNameSupplier = () -> typeNameCreator.createChildClassName(enclosingNodeType.getJavaTypeName(), javaName, mustBeTopLevel);
        javaTypeNameSupplier = new MemoizedSupplier<>(javaTypeNameSupplier);

        var customMethods = customMethodsProvider.createCustomMethods(allTypesNames);

        MultiChildType childType = new MultiChildType(genTypes, tokensChildType, enclosingNodeType, javaTypeNameSupplier, customMethods, new ArrayList<>());
        additionalTypedNodeSubtypeCollector.accept(childType);
        genTypes.forEach(t -> t.addInterfaceToImplement(childType));
        return childType;
    }

    /**
     * Adds a mapper variable with the given {@code mapperVar} name, which is used by the {@link NodeUtilsGenerator}
     * methods to convert from a jtreesitter Node to a TypedNode.
     */
    private static void addMapperVariable(MethodSpec.Builder builder, CodeGenHelper codeGenHelper, String mapperVar, GenJavaType javaType) {
        ClassName javaTypeName = javaType.getJavaTypeName();

        // Only GenNodeType classes have dedicated `fromNode` methods
        if (javaType instanceof GenNodeType) {
            var nodeType = codeGenHelper.jtreesitterConfig().node().className();
            var mapperType = ParameterizedTypeName.get(ClassName.get(Function.class), nodeType, javaTypeName);
            builder.addStatement("$T $N = $T::$N", mapperType, mapperVar, javaTypeName, codeGenHelper.typedNodeConfig().methodFromNodeThrowing());
        } else {
            // Specify mapper as `Class`
            builder.addStatement("var $N = $T.class", mapperVar, javaTypeName);
        }
    }

    /**
     * Child type which represents a single named type.
     */
    record SingleChildType(GenNodeType nodeType) implements GenChildType {
        @Override
        public Supplier<ClassName> getJavaTypeNameSupplier() {
            return nodeType::getJavaTypeName;
        }

        @Override
        public GenNodeType getRepresentedNodeType() {
            return nodeType;
        }

        @Override
        public List<TypeBuilderWithName> generateJavaTypes(CodeGenHelper codeGenHelper, String childGetterName) {
            // Refers to existing type, nothing to generate
            return List.of();
        }

        @Override
        public boolean refersToTypeThroughInterface(GenRegularNodeType type, Set<GenRegularNodeType> seenTypes) {
            // Irrelevant since no new Java interface is generated for this type
            return false;
        }

        @Override
        public void addConvertingCall(MethodSpec.Builder builder, CodeGenHelper codeGenHelper, String childrenVar, String resultVar) {
            var nodeUtils = codeGenHelper.nodeUtilsConfig();

            String mapperVar = "namedMapper";
            GenChildType.addMapperVariable(builder, codeGenHelper, mapperVar, nodeType);
            builder.addStatement("var $N = $T.$N($N, $N, null)", resultVar, nodeUtils.className(), nodeUtils.methodMapChildrenNamedNonNamed(), childrenVar, mapperVar);
        }

        @Override
        public @Nullable TokenEnumInfo getTokenEnumInfo(CodeGenHelper codeGenHelper) {
            return null;
        }
    }

    /**
     * For non-named child types, create an enum class representing all of the 'token' types,
     * and then an enclosing {@code ChildType{Node, TokenType}}.
     */
    final class UnnamedTokensChildType implements GenChildType, GenJavaType {
        private final GenRegularNodeType enclosingNodeType;
        private final ClassName javaTypeName;
        /** Map from token type name to Java constant name */
        // SequencedMap for deterministic order
        private final SequencedMap<String, String> tokensToJavaConstants;
        /** Initialized after construction */
        @Nullable
        private GenJavaInterface interfaceToImplement;

        public UnnamedTokensChildType(GenRegularNodeType enclosingNodeType, ClassName javaTypeName, SequencedMap<String, String> tokensToJavaConstants) {
            this.enclosingNodeType = enclosingNodeType;
            this.javaTypeName = javaTypeName;
            this.tokensToJavaConstants = tokensToJavaConstants;
            this.interfaceToImplement = null;
        }

        /**
         * Sets the Java interface which this child type should implement.
         *
         * <p>Calling this method is optional and depends on whether this 'tokens child type' is directly used
         * as child return type or whether a common interface for the child types is used instead.
         */
        public void setInterfaceToImplement(GenJavaInterface interfaceToImplement) {
            if (this.interfaceToImplement != null) {
                throw new IllegalStateException("Interface already defined");
            }
            this.interfaceToImplement = Objects.requireNonNull(interfaceToImplement);
        }

        @Override
        public boolean refersToTypeThroughInterface(GenRegularNodeType type, Set<GenRegularNodeType> seenTypes) {
            // Irrelevant since a Java class and not an interface is generated for this type
            return false;
        }

        @Override
        public Supplier<ClassName> getJavaTypeNameSupplier() {
            return () -> javaTypeName;
        }

        @Override
        public ClassName getJavaTypeName() {
            return javaTypeName;
        }

        @Override
        public TokenEnumInfo getTokenEnumInfo(CodeGenHelper codeGenHelper) {
            return new TokenEnumInfo(
                getTokenEnumClassName(codeGenHelper),
                new ArrayList<>(tokensToJavaConstants.keySet())
            );
        }

        @Override
        public List<GeneratedMethod> getGeneratedMethods() {
            // Currently does not support custom methods, see also CustomMethodsProvider
            return List.of();
        }

        // Internal method name
        private static final String TOKEN_ENUM_FROM_NODE_METHOD_NAME = "fromNode";

        private ClassName getTokenEnumClassName(CodeGenHelper codeGenHelper) {
            return javaTypeName.nestedClass(codeGenHelper.tokenEnumConfig().name());
        }

        /** Generates the Java enum where each constant represents one of the 'tokens' / non-named types. */
        private TypeSpec generateTokenEnum(CodeGenHelper codeGenHelper, ClassName className) {
            var tokenNode = codeGenHelper.tokenEnumConfig();

            var typeBuilder = TypeSpec.enumBuilder(className)
                .addModifiers(Modifier.PUBLIC)
                .addJavadoc("Token types:"); // remaining Javadoc is generated below

            var typeField = FieldSpec.builder(String.class, "type", Modifier.PRIVATE, Modifier.FINAL).build();
            typeBuilder.addField(typeField);

            var constructor = createInitializingConstructor(typeField);
            typeBuilder.addMethod(constructor);

            var getTypeMethod = MethodSpec.methodBuilder(tokenNode.methodGetTypeName())
                .addModifiers(Modifier.PUBLIC)
                .returns(String.class)
                .addStatement("return $N", typeField)
                .addJavadoc("Returns the grammar type of this token.")
                .build();
            typeBuilder.addMethod(getTypeMethod);

            // TODO: Should generate HTML table instead of list?
            typeBuilder.addJavadoc("\n<ul>");
            for (var token : tokensToJavaConstants.entrySet()) {
                String typeName = token.getKey();
                String constantName = token.getValue();

                // Add to enum Javadoc
                typeBuilder.addJavadoc("\n<li>{@link #$N '$L'}", constantName, CodeGenHelper.escapeJavadocText(typeName));

                var enumConstant = TypeSpec.anonymousClassBuilder("$S", typeName)
                    .addJavadoc(CodeGenHelper.createJavadocCodeTag(typeName))
                    .build();
                typeBuilder.addEnumConstant(constantName, enumConstant);
            }
            typeBuilder.addJavadoc("\n</ul>");

            var jtreesitterNode = codeGenHelper.jtreesitterConfig().node();
            String nodeParam = "node";
            String typeVar = "type";
            String tokenVar = "token";
            // package-private because this is an internal method
            var fromNodeMethod = MethodSpec.methodBuilder(TOKEN_ENUM_FROM_NODE_METHOD_NAME)
                .addModifiers(Modifier.STATIC)
                .addParameter(jtreesitterNode.className(), nodeParam)
                .returns(className)
                .addStatement("var $N = $N.$N()", typeVar, nodeParam, jtreesitterNode.methodGetType())
                .beginControlFlow("for (var $N : values())", tokenVar)
                .beginControlFlow("if ($N.$N.equals($N))", tokenVar, typeField, typeVar)
                .addStatement("return $N", tokenVar)
                .endControlFlow()
                .endControlFlow()
                .addComment("Should not happen since all non-named child types are covered")
                .addStatement("throw new $T(\"Unknown token type: \" + $N)", IllegalArgumentException.class, typeVar)
                .build();
            typeBuilder.addMethod(fromNodeMethod);

            return typeBuilder.build();
        }

        /** Generates {@code Object} methods such as {@code equals}, {@code hashCode} and {@code toString}. */
        private void generateOverriddenObjectMethods(TypeSpec.Builder typeBuilder, CodeGenHelper codeGenHelper, String nodeField, String tokenField) {
            var equalsMethod = CodeGenHelper.createDelegatingEqualsMethod(javaTypeName, nodeField);
            typeBuilder.addMethod(equalsMethod);

            var hashCodeMethod = CodeGenHelper.createDelegatingHashCodeMethod(nodeField);
            typeBuilder.addMethod(hashCodeMethod);

            var jtreesitterNode = codeGenHelper.jtreesitterConfig().node();
            var toStringMethod = CodeGenHelper.createToStringMethodSignature()
                // TODO: Include more information, e.g. position information? Or include wrapped node.toString()?
                .addStatement("return $S + \"[id=\" + $T.toUnsignedString($N.$N()) + \",token=\" + $N + \"]\"", javaTypeName.simpleName(), Long.class, nodeField, jtreesitterNode.methodGetId(), tokenField)
                .build();
            typeBuilder.addMethod(toStringMethod);
        }

        private void generateJavadoc(TypeSpec.Builder typeBuilder, String childGetterName, String tokenGetterName) {
            typeBuilder.addJavadoc("Child node type without name, returned by {@link $T#$N}.\n", enclosingNodeType.getJavaTypeName(), childGetterName);
            typeBuilder.addJavadoc("<p>The type of the node can be obtained using {@link #$N}.", tokenGetterName);
        }

        @Override
        public List<TypeBuilderWithName> generateJavaTypes(CodeGenHelper codeGenHelper, String childGetterName) {
            var typeBuilder = TypeSpec.classBuilder(javaTypeName)
                .addModifiers(Modifier.PUBLIC, Modifier.FINAL);

            boolean asTopLevel = javaTypeName.enclosingClassName() == null;
            if (!asTopLevel) {
                typeBuilder.addModifiers(Modifier.STATIC);
            }

            String tokenGetterName = codeGenHelper.tokenEnumConfig().enclosingMethodGetToken();
            generateJavadoc(typeBuilder, childGetterName, tokenGetterName);

            if (interfaceToImplement == null) {
                typeBuilder.addSuperinterface(codeGenHelper.typedNodeConfig().className());
            } else {
                typeBuilder.addSuperinterface(interfaceToImplement.getJavaTypeName());
            }

            var tokenClassName = getTokenEnumClassName(codeGenHelper);
            var tokenType = generateTokenEnum(codeGenHelper, tokenClassName);
            // Add as nested type
            typeBuilder.addType(tokenType);

            String nodeField = "node";
            String tokenField = "token";
            TypedNodeInterfaceGenerator.generateTypedNodeImplementation(typeBuilder, codeGenHelper, nodeField, new TypedNodeInterfaceGenerator.JavaFieldData(tokenClassName, tokenField));

            var getTokenTypeMethod = MethodSpec.methodBuilder(tokenGetterName)
                .addModifiers(Modifier.PUBLIC)
                .returns(tokenClassName)
                .addJavadoc("Returns the token type.")
                .addStatement("return $N", tokenField)
                .build();
            typeBuilder.addMethod(getTokenTypeMethod);

            generateOverriddenObjectMethods(typeBuilder, codeGenHelper, nodeField, tokenField);

            return List.of(new TypeBuilderWithName(typeBuilder, javaTypeName));
        }

        /**
         * Adds a mapper variable with the given {@code mapperVar} name, which is used by the {@link NodeUtilsGenerator}
         * methods to convert from a jtreesitter Node to a TypedNode.
         */
        void addMapperVariable(MethodSpec.Builder builder, CodeGenHelper codeGenHelper, String mapperVar) {
            var nodeType = codeGenHelper.jtreesitterConfig().node().className();
            var mapperType = ParameterizedTypeName.get(ClassName.get(Function.class), nodeType, javaTypeName);
            builder.addStatement("$T $N = n -> new $T(n, $T.$N(n))", mapperType, mapperVar, javaTypeName, getTokenEnumClassName(codeGenHelper), TOKEN_ENUM_FROM_NODE_METHOD_NAME);
        }

        @Override
        public void addConvertingCall(MethodSpec.Builder builder, CodeGenHelper codeGenHelper, String childrenVar, String resultVar) {
            var nodeUtils = codeGenHelper.nodeUtilsConfig();
            String mapperVar = "mapper";
            addMapperVariable(builder, codeGenHelper, mapperVar);

            // Cast `null` to `Class<...>` to avoid overload ambiguity
            var ownClassType = ParameterizedTypeName.get(ClassName.get(Class.class), javaTypeName);
            builder.addStatement("var $N = $T.$N($N, ($T) null, $N)", resultVar, nodeUtils.className(), nodeUtils.methodMapChildrenNamedNonNamed(), childrenVar, ownClassType, mapperVar);
        }
    }

    /**
     * Child type which represents multiple types, including at least one named type.
     * May optionally include non-named types as part of {@code tokensChildType}.
     *
     * <p>A single named type is represented by {@link SingleChildType}.
     */
    record MultiChildType(
        List<GenNodeType> types,
        @Nullable UnnamedTokensChildType tokensChildType,
        GenRegularNodeType enclosingNodeType,
        Supplier<ClassName> javaTypeNameSupplier,
        List<CustomMethodData> customMethods,
        // commonMethods are populated after construction
        List<GeneratedMethod> commonMethods
    ) implements GenChildType, GenJavaInterface {
        public MultiChildType {
            if (tokensChildType != null) {
                tokensChildType.setInterfaceToImplement(this);
            }
        }

        @Override
        public boolean refersToTypeThroughInterface(GenRegularNodeType type, Set<GenRegularNodeType> seenTypes) {
            return types.stream().anyMatch(t -> t.refersToType(type, seenTypes));
        }

        @Override
        public Supplier<ClassName> getJavaTypeNameSupplier() {
            return javaTypeNameSupplier;
        }

        @Override
        public ClassName getJavaTypeName() {
            return javaTypeNameSupplier.get();
        }

        @Override
        public List<? extends GenJavaType> getSubtypes() {
            var subtypes = new ArrayList<GenJavaType>(types);
            if (tokensChildType != null) {
                subtypes.add(tokensChildType);
            }

            return subtypes;
        }

        @Override
        public List<GeneratedMethod> getGeneratedMethods() {
            return customMethods.stream().map(CustomMethodData::asGeneratedMethod).toList();
        }

        @Override
        public void setCommonMethods(Collection<GeneratedMethod> commonMethods) {
            if (!this.commonMethods.isEmpty()) {
                throw new IllegalStateException("Common methods have already been set");
            }
            this.commonMethods.addAll(commonMethods);
        }

        @Override
        public @Nullable TokenEnumInfo getTokenEnumInfo(CodeGenHelper codeGenHelper) {
            if (tokensChildType == null) {
                return null;
            }
            return tokensChildType.getTokenEnumInfo(codeGenHelper);
        }

        private void generateJavadoc(TypeSpec.Builder typeBuilder, CodeGenHelper codeGenHelper, String childGetterName) {
            typeBuilder.addJavadoc("Child type returned by {@link $T#$N}.\n", enclosingNodeType.getJavaTypeName(), childGetterName);
            typeBuilder.addJavadoc("<p>Possible types:");
            codeGenHelper.addJavadocTypeMapping(typeBuilder, types, tokensChildType);

            CustomMethodData.createCustomMethodsJavadocSection(customMethods).ifPresent(typeBuilder::addJavadoc);
        }

        @Override
        public List<TypeBuilderWithName> generateJavaTypes(CodeGenHelper codeGenHelper, String childGetterName) {
            var javaTypeName = getJavaTypeName();
            var typeBuilder = TypeSpec.interfaceBuilder(javaTypeName)
                .addModifiers(Modifier.PUBLIC, Modifier.SEALED)
                .addSuperinterface(codeGenHelper.typedNodeConfig().className());

            for (var subtype : types) {
                typeBuilder.addPermittedSubclass(subtype.getJavaTypeName());
            }

            generateJavadoc(typeBuilder, codeGenHelper, childGetterName);

            List<TypeBuilderWithName> javaTypes = new ArrayList<>();
            if (tokensChildType != null) {
                typeBuilder.addPermittedSubclass(tokensChildType.getJavaTypeName());
                javaTypes.addAll(tokensChildType.generateJavaTypes(codeGenHelper, childGetterName));
            }

            customMethods.forEach(m -> typeBuilder.addMethod(m.generateMethod(true)));

            commonMethods.forEach(m -> typeBuilder.addMethod(m.createCommonInterfaceMethodSpec()));

            javaTypes.add(new TypeBuilderWithName(typeBuilder, javaTypeName));

            return javaTypes;
        }

        @Override
        public void addConvertingCall(MethodSpec.Builder builder, CodeGenHelper codeGenHelper, String childrenVar, String resultVar) {
            var nodeUtils = codeGenHelper.nodeUtilsConfig();

            String namedMapperVar = "namedMapper";
            // If refers only to 1 other named type, can generate more efficient code by using its `fromNode` method
            // instead of `TypedNode#fromNode`
            var javaType = types.size() == 1 ? types.getFirst() : this;
            GenChildType.addMapperVariable(builder, codeGenHelper, namedMapperVar, javaType);

            if (tokensChildType == null) {
                builder.addStatement("var $N = $T.$N($N, $N, null)", resultVar, nodeUtils.className(), nodeUtils.methodMapChildrenNamedNonNamed(), childrenVar, namedMapperVar);
            } else {
                String tokenMapperVar = "tokenMapper";
                tokensChildType.addMapperVariable(builder, codeGenHelper, tokenMapperVar);
                builder.addStatement("var $N = $T.$N($N, $N, $N)", resultVar, nodeUtils.className(), nodeUtils.methodMapChildrenNamedNonNamed(), childrenVar, namedMapperVar, tokenMapperVar);
            }
        }
    }
}
