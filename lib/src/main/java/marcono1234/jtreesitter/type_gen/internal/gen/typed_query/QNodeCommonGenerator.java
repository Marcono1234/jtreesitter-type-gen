package marcono1234.jtreesitter.type_gen.internal.gen.typed_query;

import com.palantir.javapoet.*;
import marcono1234.jtreesitter.type_gen.internal.gen.utils.CodeGenHelper;

import javax.lang.model.element.Modifier;

import java.util.List;
import java.util.function.Predicate;
import java.util.stream.Stream;

import static marcono1234.jtreesitter.type_gen.internal.gen.utils.CodeGenHelper.*;

/**
 * Code generator for all common {@code QNode} types, except for {@code QTypedNode} and subclasses which are
 * generated by {@link QTypedNodeGenerator}.
 * The code generation is performed by {@link #generateBuilderClass(List)} and {@link #generateTypes()}.
 */
class QNodeCommonGenerator {
    final CodeGenHelper codeGenHelper;
    final TypedQueryConfig typedQueryConfig;
    final TypeVariableName typeVarCollector;
    private final TypeVariableName typeVarNode;
    final TypeVariableName typeVarNodeBound;

    private final ParameterizedTypeName typeQNode;
    private final ParameterizedTypeName typeQNodeImpl;
    private final ParameterizedTypeName typeQQuantifiable;
    private final ParameterizedTypeName typeQCapturable;

    private final ParameterSpec paramLanguage;
    final ParameterSpec paramQueryStringBuilder;
    final ParameterSpec paramCaptureRegistry;
    final ParameterSpec paramPredicateRegistry;

    QNodeCommonGenerator(TypedQueryGenerator typedQueryGenerator) {
        this.codeGenHelper = typedQueryGenerator.codeGenHelper;
        this.typedQueryConfig = typedQueryGenerator.typedQueryConfig;
        this.typeVarCollector = typedQueryGenerator.typeVarCollector;
        this.typeVarNode = typedQueryGenerator.typeVarNode;
        this.typeVarNodeBound = typedQueryGenerator.typeVarNodeBound;

        this.typeQNode = ParameterizedTypeName.get(typedQueryConfig.qNodeConfig().name(), typeVarCollector, typeVarNode);
        this.typeQNodeImpl = ParameterizedTypeName.get(typedQueryConfig.qNodeImplConfig().name(), typeVarCollector, typeVarNode);
        this.typeQQuantifiable = ParameterizedTypeName.get(typedQueryConfig.qQuantifiableConfig().name(), typeVarCollector, typeVarNode);
        this.typeQCapturable = ParameterizedTypeName.get(typedQueryConfig.qCapturableConfig().name(), typeVarCollector, typeVarNodeBound);

        this.paramLanguage = ParameterSpec.builder(codeGenHelper.jtreesitterConfig().language().className(), "language").build();
        this.paramQueryStringBuilder = ParameterSpec.builder(StringBuilder.class, "queryStringBuilder").build();
        this.paramCaptureRegistry = ParameterSpec.builder(
            ParameterizedTypeName.get(typedQueryConfig.captureRegistryConfig().name(), typeVarCollector),
            "captureRegistry"
        ).build();
        this.paramPredicateRegistry = ParameterSpec.builder(typedQueryConfig.predicateRegistryConfig().name(), "predicateRegistry").build();
    }

    private MethodSpec.Builder createBuildQuerySignature() {
        var builder = MethodSpec.methodBuilder(typedQueryConfig.qNodeConfig().methodBuildQuery())
            .addModifiers(Modifier.PUBLIC)
            .returns(ParameterizedTypeName.get(typedQueryConfig.name(), typeVarCollector));

        // If Language provider is not specified, user must provide Language themselves
        if (codeGenHelper.languageUtilsConfig() == null) {
            builder.addParameter(paramLanguage);
        }
        return builder;
    }

    /**
     * Signature for the {@code buildQueryImpl} method, which is the internal implementation of the public
     * {@code buildQuery} method.
     */
    private MethodSpec.Builder createBuildQueryImplSignature() {
        return MethodSpec.methodBuilder(typedQueryConfig.qNodeImplConfig().methodBuildQueryImpl())
            .addParameter(paramQueryStringBuilder)
            .addParameter(paramCaptureRegistry)
            .addParameter(paramPredicateRegistry);
    }

    MethodSpec.Builder createBuildQueryImplOverride() {
        return createBuildQueryImplSignature().addAnnotation(Override.class);
    }

    private TypeSpec generateInterfaceQNode() {
        var qNodeConfig = typedQueryConfig.qNodeConfig();

        var methodBuildQuery = createBuildQuerySignature()
            .addModifiers(Modifier.ABSTRACT)
            .addJavadoc("Builds the typed query object, which can then be used to execute the query.")
            .build();

        return TypeSpec.interfaceBuilder(qNodeConfig.name())
            .addModifiers(Modifier.PUBLIC, Modifier.SEALED)
            .addTypeVariable(typeVarCollector)
            .addTypeVariable(typeVarNode)
            .addJavadoc("Base type for all 'typed query' builder classes.")
            .addJavadoc("\nInstances of the builder classes can be obtained from {@link $T}.", typedQueryConfig.builderConfig().name())
            .addJavadoc("\n@param <$T> type of the matched node", typeVarNode)
            .addJavadoc("\n@param <$T> type of the user-defined 'collector' which processes query captures; see the {@link $T} documentation", typeVarCollector, typedQueryConfig.name())
            .addMethod(methodBuildQuery)
            .build();
    }

    private TypeSpec generateClassQNodeImpl() {
        var qNodeImplConfig = typedQueryConfig.qNodeImplConfig();

        var methodBuildQueryImpl = createBuildQueryImplSignature().addModifiers(Modifier.ABSTRACT).build();

        MethodSpec methodVerifyValidState = MethodSpec.methodBuilder(qNodeImplConfig.methodVerifyValidState())
            .addComment("Overridden by subclasses to perform additional validation")
            .build();

        MethodSpec methodBuildQuery;
        {
            var builder = createBuildQuerySignature()
                .addAnnotation(Override.class)
                .addStatement("$N()", methodVerifyValidState);

            var languageUtilsConfig = codeGenHelper.languageUtilsConfig();
            if (languageUtilsConfig == null) {
                // Language is provided as parameter by user; validate it
                builder.addStatement(createNonNullCheck(paramLanguage));
            } else {
                builder.addStatement("var $N = $T.$N", paramLanguage, languageUtilsConfig.className(), languageUtilsConfig.fieldLanguage());
            }

            methodBuildQuery = builder
                // Use same variable names as for the parameters
                .addStatement("var $N = new $T()", paramQueryStringBuilder, StringBuilder.class)
                .addStatement("var $N = new $T()", paramCaptureRegistry, paramCaptureRegistry.type())
                .addStatement("var $N = new $T()", paramPredicateRegistry, paramPredicateRegistry.type())
                .addStatement("$N($N, $N, $N)", methodBuildQueryImpl.name(), paramQueryStringBuilder, paramCaptureRegistry, paramPredicateRegistry)
                .addStatement("return new $T<>($N, $N.toString(), $N, $N)", typedQueryConfig.name(), paramLanguage, paramQueryStringBuilder, paramCaptureRegistry, paramPredicateRegistry)
                .build();
        }

        String paramNode = "node";
        String varNode = "n";
        var methodFromNode = MethodSpec.methodBuilder(qNodeImplConfig.methodFromNode())
            .addModifiers(Modifier.STATIC)
            .addTypeVariable(typeVarCollector)
            .addTypeVariable(typeVarNode)
            .returns(typeQNodeImpl)
            .addParameter(typeQNode, paramNode)
            .addStatement(createNonNullCheck(paramNode))
            .addComment("Expect that every " + typeQNode.rawType().simpleName() + " is actually an instance of " + typeQNodeImpl.rawType().simpleName())
            .addStatement("var $N = ($T) $N", varNode, typeQNodeImpl, paramNode)
            // Verify valid node state here; this assumes that callers of this method are in the process of adding the node as nested subnode
            .addStatement("$N.$N()", varNode, methodVerifyValidState)
            .addStatement("return $N", varNode)
            .build();

        String paramNodes = "nodes";
        String varNodes = "n";
        // Type `List<QNodeImpl<C, ? extends N>>`
        var typeListQNodeImpl = ParameterizedTypeName.get(ClassName.get(List.class), ParameterizedTypeName.get(typedQueryConfig.qNodeImplConfig().name(), typeVarCollector, WildcardTypeName.subtypeOf(typeVarNode)));
        var typeListWildcard = ParameterizedTypeName.get(ClassName.get(List.class), unboundedWildcard());
        var methodListOf = MethodSpec.methodBuilder(qNodeImplConfig.methodListOf())
            .addAnnotation(SUPPRESS_WARNINGS_UNCHECKED)
            .addModifiers(Modifier.STATIC)
            .addTypeVariable(typeVarCollector)
            .addTypeVariable(typeVarNode)
            .addParameter(
                ArrayTypeName.of(ParameterizedTypeName.get(typedQueryConfig.qNodeConfig().name(), typeVarCollector, WildcardTypeName.subtypeOf(typeVarNode))),
                paramNodes
            )
            .varargs()
            .returns(typeListQNodeImpl)
            .addComment("Expect that every " + typeQNode.rawType().simpleName() + " is actually an instance of " + typeQNodeImpl.rawType().simpleName())
            // Uses `List#of` to disallow null elements
            .addStatement("var $N = ($T) ($T) $T.of($N)", varNodes, typeListQNodeImpl, typeListWildcard, List.class, paramNodes)
            // Verify valid node state here; this assumes that callers of this method are in the process of adding the given nodes as nested subnodes
            .addStatement("$N.forEach($T::$N)", varNodes, qNodeImplConfig.name(), methodVerifyValidState)
            .addStatement("return $N", varNodes)
            .build();

        String paramStr = "s";
        var methodCreateStringLiteral = MethodSpec.methodBuilder(qNodeImplConfig.methodCreateStringLiteral())
            .addModifiers(Modifier.STATIC)
            .addParameter(String.class, paramStr)
            .returns(String.class)
            // Wrap in quotes and escape, see https://github.com/tree-sitter/tree-sitter/blob/v0.26.3/lib/src/query.c#L2074-L2092
            .addStatement(CodeBlock.builder()
                .add("return \"\\\"\" + $N", paramStr)
                // \ -> \\
                .add("\n.replace(\"\\\\\", \"\\\\\\\\\")")
                // " -> \"
                .add("\n.replace(\"\\\"\", \"\\\\\\\"\")")
                // LF -> \n
                .add("\n.replace(\"\\n\", \"\\\\n\")")
                // CR -> \r
                .add("\n.replace(\"\\r\", \"\\\\r\")")
                // TAB -> \t
                .add("\n.replace(\"\\t\", \"\\\\t\")")
                // NUL -> \0
                .add("\n.replace(\"\\0\", \"\\\\0\")")
                .add("\n + \"\\\"\"")
                .build()
            )
            .build();

        return TypeSpec.classBuilder(qNodeImplConfig.name())
            // non-sealed but class is not publicly accessible
            .addModifiers(Modifier.PRIVATE, Modifier.STATIC, Modifier.ABSTRACT, Modifier.NON_SEALED)
            .addTypeVariable(typeVarCollector)
            .addTypeVariable(typeVarNode)
            .addSuperinterface(ParameterizedTypeName.get(
                typedQueryConfig.qNodeConfig().name(),
                typeVarCollector,
                typeVarNode
            ))
            .addMethod(methodVerifyValidState)
            .addMethod(methodBuildQueryImpl)
            .addMethod(methodBuildQuery)
            .addMethod(methodFromNode)
            .addMethod(methodListOf)
            .addMethod(methodCreateStringLiteral)
            .build();
    }

    private TypeSpec generateClassQQuantifiable() {
        var qQuantifiableConfig = typedQueryConfig.qQuantifiableConfig();
        var typeQQuantified = typedQueryConfig.qQuantifiedConfig().name();

        // Package-private constructor, to prevent user code from accessing it
        var constructor = MethodSpec.constructorBuilder().build();

        var methodZeroOrMore = MethodSpec.methodBuilder(qQuantifiableConfig.methodZeroOrMore())
            .addModifiers(Modifier.PUBLIC)
            .returns(typeQNode)
            .addJavadoc("Specifies that the node can occur zero or more times.")
            .addJavadoc(TreeSitterDoc.QUANTIFICATION_OPERATOR.createJavadocSee())
            .addStatement("return new $T<>(this, '*')", typeQQuantified)
            .build();

        var methodOneOrMore = MethodSpec.methodBuilder(qQuantifiableConfig.methodOneOrMore())
            .addModifiers(Modifier.PUBLIC)
            .returns(typeQNode)
            .addJavadoc("Specifies that the node must occur one or more times.")
            .addJavadoc(TreeSitterDoc.QUANTIFICATION_OPERATOR.createJavadocSee())
            .addStatement("return new $T<>(this, '+')", typeQQuantified)
            .build();

        var methodOptional = MethodSpec.methodBuilder(qQuantifiableConfig.methodOptional())
            .addModifiers(Modifier.PUBLIC)
            .returns(typeQNode)
            .addJavadoc("Specifies that the node is optional (can occur zero or one time).")
            .addJavadoc(TreeSitterDoc.QUANTIFICATION_OPERATOR.createJavadocSee())
            .addStatement("return new $T<>(this, '?')", typeQQuantified)
            .build();

        // Important: When adding more methods in the future, generate overrides in `generateQCapturableQuantifiable`

        return TypeSpec.classBuilder(qQuantifiableConfig.name())
            .addModifiers(Modifier.PUBLIC, Modifier.STATIC, Modifier.ABSTRACT)
            .addTypeVariable(typeVarCollector)
            .addTypeVariable(typeVarNode)
            .superclass(typeQNodeImpl)
            .addJavadoc("Allows specifying how often a node should be matched by the query.")
            .addJavadoc(TreeSitterDoc.QUANTIFICATION_OPERATOR.createJavadocSee())
            .addMethod(constructor)
            .addMethod(methodZeroOrMore)
            .addMethod(methodOneOrMore)
            .addMethod(methodOptional)
            .build();
    }

    /**
     * Creates code which performs a delegating call to the {@code QNodeImpl#buildQuery} method of
     * {@code varDelegateNode}.
     */
    CodeBlock createDelegatingBuildQueryCall(String varDelegateNode) {
        return CodeBlock.of("$N.$N($N, $N, $N)",
            varDelegateNode,
            typedQueryConfig.qNodeImplConfig().methodBuildQueryImpl(),
            paramQueryStringBuilder, paramCaptureRegistry, paramPredicateRegistry
        );
    }

    private TypeSpec generateClassQQuantified() {
        var qQuantifiedConfig = typedQueryConfig.qQuantifiedConfig();

        var fieldNode = FieldSpec.builder(typeQNodeImpl, qQuantifiedConfig.fieldNode(), Modifier.PRIVATE, Modifier.FINAL).build();
        var fieldQuantifier = FieldSpec.builder(char.class, qQuantifiedConfig.fieldQuantifier(), Modifier.PRIVATE, Modifier.FINAL).build();

        var constructor = createInitializingConstructorBuilder(fieldNode, fieldQuantifier)
            // Must verify state here because callers of constructor are already `QNodeImpl` so they just pass `this`
            // and don't call `QNodeImpl#from` which normally performs this verification
            .addStatement("$N.$N()", fieldNode, typedQueryConfig.qNodeImplConfig().methodVerifyValidState())
            .build();

        var methodBuildQuery = createBuildQueryImplOverride()
            .addStatement(createDelegatingBuildQueryCall(fieldNode.name()))
            .addStatement("$N.append($N)", paramQueryStringBuilder, fieldQuantifier)
            .build();

        return TypeSpec.classBuilder(qQuantifiedConfig.name())
            .addModifiers(Modifier.PRIVATE, Modifier.STATIC)
            .addTypeVariable(typeVarCollector)
            .addTypeVariable(typeVarNode)
            // Do not use 'quantifiable' as superclass, to prevent applying multiple quantifiers to same node
            .superclass(typeQNodeImpl)
            .addField(fieldNode)
            .addField(fieldQuantifier)
            .addMethod(constructor)
            .addMethod(methodBuildQuery)
            .build();
    }

    // Note: QGroup might be a bit problematic because for the query builder it looks like it matches a single node
    // but it actually matches an arbitrary number of nodes (though the same problem exists for QQuantified as well)
    private TypeSpec generateClassQGroup() {
        var typeListQNodeImplWildcard = ParameterizedTypeName.get(
            ClassName.get(List.class),
            ParameterizedTypeName.get(
                typedQueryConfig.qNodeImplConfig().name(),
                typeVarCollector,
                WildcardTypeName.subtypeOf(typeVarNode)
            )
        );
        var fieldNodes = FieldSpec.builder(typeListQNodeImplWildcard, "nodes", Modifier.PRIVATE, Modifier.FINAL).build();

        var constructor = createInitializingConstructorBuilder(fieldNodes)
            .addStatement("if ($N.isEmpty()) throw new $T(\"Must specify at least one node\")", fieldNodes, IllegalArgumentException.class)
            .build();

        var methodBuildQuery = createBuildQueryImplOverride()
            .addStatement("$N.append('(')", paramQueryStringBuilder)
            .addStatement(CodeBlock.builder()
                .add("$N.forEach(n -> {\n", fieldNodes).indent()
                .add(createDelegatingBuildQueryCall("n")).add(";\n")
                .add("$N.append(' ');\n", paramQueryStringBuilder)
                .unindent()
                .add("})")
                .build()
            )
            .addStatement("$N.append(')')", paramQueryStringBuilder)
            .build();

        return TypeSpec.classBuilder(typedQueryConfig.classQGroup())
            .addModifiers(Modifier.PRIVATE, Modifier.STATIC)
            .addTypeVariable(typeVarCollector)
            .addTypeVariable(typeVarNode)
            .superclass(typeQQuantifiable)
            .addField(fieldNodes)
            .addMethod(constructor)
            .addMethod(methodBuildQuery)
            .build();
    }

    private TypeSpec generateClassQAlternation(boolean typed) {
        var typeVarNode = typed ? this.typeVarNodeBound : this.typeVarNode;
        // Type `List<QNodeImpl<C, ? extends N>>`
        var typeListQNodeImplWildcard = ParameterizedTypeName.get(
            ClassName.get(List.class),
            ParameterizedTypeName.get(
                typedQueryConfig.qNodeImplConfig().name(),
                typeVarCollector,
                WildcardTypeName.subtypeOf(typeVarNode)
            )
        );
        var fieldNodes = FieldSpec.builder(typeListQNodeImplWildcard, "nodes", Modifier.PRIVATE, Modifier.FINAL).build();

        var constructor = createInitializingConstructorBuilder(fieldNodes)
            .addStatement("if ($N.isEmpty()) throw new $T(\"Must specify at least one node\")", fieldNodes, IllegalArgumentException.class)
            .build();

        var methodBuildQuery = createBuildQueryImplOverride()
            .addStatement("$N.append('[')", paramQueryStringBuilder)
            .addStatement(CodeBlock.builder()
                .add("$N.forEach(n -> {\n", fieldNodes).indent()
                .add(createDelegatingBuildQueryCall("n")).add(";\n")
                .add("$N.append(' ');\n", paramQueryStringBuilder)
                .unindent()
                .add("})")
                .build()
            )
            .addStatement("$N.append(']')", paramQueryStringBuilder)
            .build();

        return TypeSpec.classBuilder(typedQueryConfig.classQAlternation(typed))
            .addModifiers(Modifier.PRIVATE, Modifier.STATIC)
            .addTypeVariable(typeVarCollector)
            .addTypeVariable(typeVarNode)
            .superclass(typed
                ? ParameterizedTypeName.get(typedQueryConfig.classQCapturableQuantifiable(), typeVarCollector, typeVarNodeBound)
                : typeQQuantifiable
            )
            .addField(fieldNodes)
            .addMethod(constructor)
            .addMethod(methodBuildQuery)
            .build();
    }

    private TypeSpec generateClassQUnnamedNode() {
        var qUnnamedNodeConfig = typedQueryConfig.qUnnamedNodeConfig();

        var fieldSupertype = FieldSpec.builder(String.class, "supertype", Modifier.PRIVATE, Modifier.FINAL)
            .addJavadoc("nullable")  // don't use @Nullable to not make any assumptions about libraries used by jtreesitter
            .build();
        var fieldNodeType = FieldSpec.builder(String.class, "nodeType", Modifier.PRIVATE, Modifier.FINAL).build();

        MethodSpec methodCheckUnnamedNodeType;
        {
            var methodBuilder = MethodSpec.methodBuilder(qUnnamedNodeConfig.methodCheckUnnamedNodeType())
                // Package-private to allow usage from QMissingNode
                .addModifiers(Modifier.STATIC)
                // For simplicity just use the same names as the fields
                .addParameter(paramFromField(fieldSupertype))
                .addParameter(paramFromField(fieldNodeType));

            var languageConfig = codeGenHelper.jtreesitterConfig().language();

            // TODO: Instead of performing this validation using `Language`, could instead retrieve this information from node-types.json
            //   and then have a `Map<String, Set<String>>`, mapping from unnamed node types to their supertypes (possibly empty)
            var languageUtilsConfig = codeGenHelper.languageUtilsConfig();
            // If Language object is available, perform additional validation to fail fast
            // However, for invalid queries tree-sitter would also fail when building query in the end
            if (languageUtilsConfig == null) {
                methodBuilder.addComment("No-op because $N object is not available", languageConfig.className().simpleName());
            } else {
                String varLanguage = "language";
                String varTypeId = "typeId";
                String varTypeIdSupertype = "supertypeId";
                String varFoundSubtype = "foundSubtype";
                String varTypeIdSubtype = "subtypeId";

                methodBuilder
                    .addStatement("var $N = $T.$N", varLanguage, languageUtilsConfig.className(), languageUtilsConfig.fieldLanguage())
                    .addStatement("var $N = $N.$N($N, false)", varTypeId, varLanguage, languageConfig.methodGetTypeId(), fieldNodeType)
                    .addStatement("if ($N == 0) throw new $T(\"Unknown unnamed node type: \" + $N)", varTypeId, IllegalArgumentException.class, fieldNodeType)
                    .beginControlFlow("if ($N != null)", fieldSupertype)
                    .addStatement("var $N = $N.$N($N, true)", varTypeIdSupertype, varLanguage, languageConfig.methodGetTypeId(), fieldSupertype)
                    .addStatement("if ($N == 0) throw new $T(\"Unknown supertype node type: \" + $N)", varTypeIdSupertype, IllegalArgumentException.class, fieldSupertype)
                    .addStatement("var $N = false", varFoundSubtype)
                    .beginControlFlow("for (var $N : $N.$N($N))", varTypeIdSubtype, varLanguage, languageConfig.methodGetSubtypes(), varTypeIdSupertype)
                    .beginControlFlow("if ($N == $N)", varTypeIdSubtype, varTypeId)
                    .addStatement("$N = true", varFoundSubtype)
                    .addStatement("break")
                    .endControlFlow()
                    .endControlFlow()
                    .addStatement("if (!$N) throw new $T(\"Node type '\" + $N + \"' is not a supertype of '\" + $N + \"'\")", varFoundSubtype, IllegalArgumentException.class, fieldSupertype, fieldNodeType)
                    .endControlFlow();
            }

            methodCheckUnnamedNodeType = methodBuilder.build();
        }

        var constructor = createInitializingConstructorBuilder(fieldSupertype, fieldNodeType)
            .addStatement(createNonNullCheck(fieldNodeType))
            .addStatement("$N($N, $N)", methodCheckUnnamedNodeType, fieldSupertype, fieldNodeType)
            .build();

        var methodBuildQuery = createBuildQueryImplOverride()
            .beginControlFlow("if ($N != null)", fieldSupertype)
            .addStatement("$N.append('(').append($N).append('/')", paramQueryStringBuilder, fieldSupertype)
            .endControlFlow()
            .addStatement("$N.append($N($N))", paramQueryStringBuilder, typedQueryConfig.qNodeImplConfig().methodCreateStringLiteral(), fieldNodeType)
            .beginControlFlow("if ($N != null)", fieldSupertype)
            .addStatement("$N.append(')')", paramQueryStringBuilder)
            .endControlFlow()
            .build();

        return TypeSpec.classBuilder(typedQueryConfig.qUnnamedNodeConfig().name())
            // Package-private class to allow `fieldToken...` methods to access the constructor
            .addModifiers(Modifier.STATIC)
            .addTypeVariable(typeVarCollector)
            .addTypeVariable(typeVarNode)
            .superclass(typeQQuantifiable)
            .addField(fieldSupertype)
            .addField(fieldNodeType)
            .addMethod(constructor)
            .addMethod(methodCheckUnnamedNodeType)
            .addMethod(methodBuildQuery)
            .build();
    }

    private TypeSpec generateClassQWildcardNode() {
        var qWildcardNodeConfig = typedQueryConfig.qWildcardNodeConfig();

        var typeSelfWildcard = ParameterizedTypeName.get(
            qWildcardNodeConfig.name(),
            unboundedWildcard(),
            unboundedWildcard()
        );
        var constantNamed = FieldSpec.builder(typeSelfWildcard, qWildcardNodeConfig.constantNamed(), Modifier.STATIC, Modifier.FINAL)
            .initializer("new $T<>(true)", qWildcardNodeConfig.name())
            .build();
        var constantNamedOrUnnamed = FieldSpec.builder(typeSelfWildcard, qWildcardNodeConfig.constantNamedOrUnnamed(), Modifier.STATIC, Modifier.FINAL)
            .initializer("new $T<>(false)", qWildcardNodeConfig.name())
            .build();
        var fieldIsNamed = FieldSpec.builder(boolean.class, "isNamed", Modifier.PRIVATE, Modifier.FINAL).build();

        var constructor = createInitializingConstructor(fieldIsNamed);

        var methodBuildQuery = createBuildQueryImplOverride()
            .addComment("Wrap wildcard `_` (named or unnamed) in an alternation as `[_]` to avoid accidentally turning it into a named-only `(_)` when wrapped for example in a group")
            .addStatement("$N.append($N ? '(' : '[')", paramQueryStringBuilder, fieldIsNamed)
            .addStatement("$N.append('_')", paramQueryStringBuilder)
            .addStatement("$N.append($N ? ')' : ']')", paramQueryStringBuilder, fieldIsNamed)
            .build();

        return TypeSpec.classBuilder(qWildcardNodeConfig.name())
            .addModifiers(Modifier.PRIVATE, Modifier.STATIC)
            .addTypeVariable(typeVarCollector)
            .addTypeVariable(typeVarNode)
            .superclass(typeQQuantifiable)
            .addField(constantNamed)
            .addField(constantNamedOrUnnamed)
            .addField(fieldIsNamed)
            .addMethod(constructor)
            .addMethod(methodBuildQuery)
            .build();
    }

    private TypeSpec generateClassQErrorNode() {
        var qErrorNodeConfig = typedQueryConfig.qErrorNodeConfig();

        var typeSelfWildcard = ParameterizedTypeName.get(
            qErrorNodeConfig.name(),
            unboundedWildcard(),
            unboundedWildcard()
        );
        var constantInstance = FieldSpec.builder(typeSelfWildcard, qErrorNodeConfig.constantInstance(), Modifier.STATIC, Modifier.FINAL)
            .initializer("new $T<>()", qErrorNodeConfig.name())
            .build();

        var constructor = MethodSpec.constructorBuilder().addModifiers(Modifier.PRIVATE).build();

        var methodBuildQuery = createBuildQueryImplOverride()
            .addStatement("$N.append(\"(ERROR)\")", paramQueryStringBuilder)
            .build();

        return TypeSpec.classBuilder(qErrorNodeConfig.name())
            .addModifiers(Modifier.PRIVATE, Modifier.STATIC)
            .addTypeVariable(typeVarCollector)
            .addTypeVariable(typeVarNode)
            .superclass(typeQQuantifiable)
            .addField(constantInstance)
            .addMethod(constructor)
            .addMethod(methodBuildQuery)
            .build();
    }

    private TypeSpec generateClassQMissingNode() {
        var qMissingNodeConfig = typedQueryConfig.qMissingNodeConfig();
        var qUnnamedNodeConfig = typedQueryConfig.qUnnamedNodeConfig();

        var typeSelfWildcard = ParameterizedTypeName.get(
            qMissingNodeConfig.name(),
            unboundedWildcard(),
            unboundedWildcard()
        );
        var constantAny = FieldSpec.builder(typeSelfWildcard, qMissingNodeConfig.constantAny(), Modifier.STATIC, Modifier.FINAL)
            .initializer("new $T<>(null, false)", qMissingNodeConfig.name())
            .build();
        var fieldNodeType = FieldSpec.builder(String.class, "nodeType", Modifier.PRIVATE, Modifier.FINAL)
            .addJavadoc("nullable")  // don't use @Nullable to not make any assumptions about libraries used by jtreesitter
            .build();
        var fieldIsUnnamed = FieldSpec.builder(boolean.class, "isUnnamed", Modifier.PRIVATE, Modifier.FINAL).build();

        // TODO: How to generate code which allows constructing specific missing nodes in a type-safe way?
        //   Currently only the `QMissingNode#ANY` variant is available through the typed query API
        //   Maybe add `asMissing()` to `QUnnamedNode` and `QTypedNode`?
        //   but for typed node have to make sure no children, fields or captures have been specified yet
        var constructor = createInitializingConstructorBuilder(fieldNodeType, fieldIsUnnamed)
            .addStatement("if ($N) $T.$N(null, $N)", fieldIsUnnamed, qUnnamedNodeConfig.name(), qUnnamedNodeConfig.methodCheckUnnamedNodeType(), fieldNodeType)
            .build();

        var methodBuildQuery = createBuildQueryImplOverride()
            .addStatement("$N.append(\"(MISSING\")", paramQueryStringBuilder)
            .beginControlFlow("if ($N != null)", fieldNodeType)
            .addStatement("$N.append(' ')", paramQueryStringBuilder)
            .beginControlFlow("if ($N)", fieldIsUnnamed)
            .addStatement("$N.append($N($N))", paramQueryStringBuilder, typedQueryConfig.qNodeImplConfig().methodCreateStringLiteral(), fieldNodeType)
            .nextControlFlow("else")
            .addStatement("$N.append($N)", paramQueryStringBuilder, fieldNodeType)
            .endControlFlow()
            .endControlFlow()
            .addStatement("$N.append(')')", paramQueryStringBuilder)
            .build();

        return TypeSpec.classBuilder(qMissingNodeConfig.name())
            .addModifiers(Modifier.PRIVATE, Modifier.STATIC)
            .addTypeVariable(typeVarCollector)
            .addTypeVariable(typeVarNode)
            .superclass(typeQQuantifiable)
            .addField(constantAny)
            .addField(fieldNodeType)
            .addField(fieldIsUnnamed)
            .addMethod(constructor)
            .addMethod(methodBuildQuery)
            .build();
    }

    private CodeBlock createQFilteredReturn(String varPredicate) {
        var qNodeImp = typedQueryConfig.qNodeImplConfig();

        return CodeBlock.builder()
            .add("return new $T<>(", typedQueryConfig.qFilteredConfig().name())
            .add("$T.$N(this), ", qNodeImp.name(), qNodeImp.methodFromNode())
            .add("$N", varPredicate)
            .add(")")
            .build();
    }

    private TypeSpec generateInterfaceQFilterable() {
        var qFilterableConfig = typedQueryConfig.qFilterableConfig();
        var qFilteredConfig = typedQueryConfig.qFilteredConfig();
        var jtreesitterNode = codeGenHelper.jtreesitterConfig().node();

        // Only support filtering of typed nodes
        var typeVarNode = this.typeVarNodeBound;

        String paramStr = "s";
        // Note: Avoid a name conflict with the `paramPredicate` below
        String varPredicate = "p";
        var methodTextEq = MethodSpec.methodBuilder(qFilterableConfig.methodTextEq())
            .addModifiers(Modifier.PUBLIC, Modifier.DEFAULT)
            .returns(typeQCapturable)
            .addParameter(String.class, paramStr)
            .addJavadoc("Specifies that the {@linkplain $T#$N text of the node} must be equal to the given text.", jtreesitterNode.className(), jtreesitterNode.methodGetText())
            // Uses `List#of` to disallow null elements
            .addStatement("var $N = new $T(\"eq\", $T.of($N))", varPredicate, qFilteredConfig.classBuiltinPredicate(), List.class, paramStr)
            .addStatement(createQFilteredReturn(varPredicate))
            .build();

        var methodTextNotEq = MethodSpec.methodBuilder(qFilterableConfig.methodTextNotEq())
            .addModifiers(Modifier.PUBLIC, Modifier.DEFAULT)
            .returns(typeQCapturable)
            .addParameter(String.class, paramStr)
            .addJavadoc("Specifies that the {@linkplain $T#$N text of the node} must not be equal the given text.", jtreesitterNode.className(), jtreesitterNode.methodGetText())
            // Uses `List#of` to disallow null elements
            .addStatement("var $N = new $T(\"not-eq\", $T.of($N))", varPredicate, qFilteredConfig.classBuiltinPredicate(), List.class, paramStr)
            .addStatement(createQFilteredReturn(varPredicate))
            .build();

        String varStrings = "strings";
        var methodTextAnyOf = MethodSpec.methodBuilder(qFilterableConfig.methodTextAnyOf())
            .addModifiers(Modifier.PUBLIC, Modifier.DEFAULT)
            .returns(typeQCapturable)
            .addParameter(ArrayTypeName.of(String.class), paramStr)
            .varargs()
            .addJavadoc("Specifies that the {@linkplain $T#$N text of the node} must be equal to any of the given texts.", jtreesitterNode.className(), jtreesitterNode.methodGetText())
            // Uses `List#of` to disallow null elements
            .addStatement("var $N = $T.of($N)", varStrings, List.class, paramStr)
            .addStatement("if ($N.isEmpty()) throw new $T(\"Must specify at least one string\")", varStrings, IllegalArgumentException.class)
            .addStatement("var $N = new $T(\"any-of\", $N)", varPredicate, qFilteredConfig.classBuiltinPredicate(), varStrings)
            .addStatement(createQFilteredReturn(varPredicate))
            .build();

        // Don't support `#match?` regex predicate; a type-safe implementation should accept a Java `Pattern` but then
        // would have to convert it to string just so that jtreesitter in the end recreates it as `Pattern`, which is
        // inefficient and error-prone; maybe users should rather use a custom predicate for it


        String paramPredicate = "predicate";
        // Type `Predicate<Stream<TypedNode>>`; used by the internal implementation to avoid casting later
        var typePredicateStream = ParameterizedTypeName.get(ClassName.get(Predicate.class), ParameterizedTypeName.get(ClassName.get(Stream.class), codeGenHelper.typedNodeConfig().className()));
        var typePredicateWildcard = ParameterizedTypeName.get(ClassName.get(Predicate.class), unboundedWildcard());
        String varPredicateU = "predicateU";
        var methodMatching = MethodSpec.methodBuilder(qFilterableConfig.methodMatching())
            .addModifiers(Modifier.PUBLIC, Modifier.DEFAULT)
            .returns(typeQCapturable)
            .addParameter(
                // Type `Predicate<? super Stream<N>>`
                // Uses `Stream` instead of `List` since internal mapping of nodes obtains `Stream` anyway, and that also
                // makes it easier for user to directly call `anyOf` or `allOf` to check all nodes
                ParameterizedTypeName.get(
                    ClassName.get(Predicate.class),
                    WildcardTypeName.supertypeOf(ParameterizedTypeName.get(ClassName.get(Stream.class), typeVarNode))),
                paramPredicate
            )
            .addJavadoc("Specifies that the nodes must fulfill the given predicate.")
            .addStatement(createNonNullCheck(paramPredicate))
            // Note: In the generated code IntelliJ claims the cast to `typePredicateWildcard` (`Predicate<?>`) is redundant, but without it compilation fails
            .addStatement("$L var $N = ($T) ($T) $N", SUPPRESS_WARNINGS_UNCHECKED, varPredicateU, typePredicateStream, typePredicateWildcard, paramPredicate)
            .addStatement("var $N = new $T($N)", varPredicate, qFilteredConfig.classCustomPredicate(), varPredicateU)
            .addStatement(createQFilteredReturn(varPredicate))
            .build();

        return TypeSpec.interfaceBuilder(qFilterableConfig.name())
            .addModifiers(Modifier.PUBLIC, Modifier.SEALED)
            .addTypeVariable(typeVarCollector)
            .addTypeVariable(typeVarNode)
            .addSuperinterface(typeQNode)
            .addJavadoc("Allows specifying predicates which the node must fulfill.")
            .addMethod(methodTextEq)
            .addMethod(methodTextNotEq)
            .addMethod(methodTextAnyOf)
            .addMethod(methodMatching)
            .build();
    }

    private MethodSpec.Builder createQPredicateBuildMethodSignature() {
        return MethodSpec.methodBuilder("build")
            // Note: This method is not part of the API; it is only a public method of an internal interface
            .addModifiers(Modifier.PUBLIC)
            .addParameter(paramQueryStringBuilder)
            .addParameter(paramPredicateRegistry);
    }

    private TypeSpec generateClassQFiltered() {
        var qFilteredConfig = typedQueryConfig.qFilteredConfig();

        var methodBuild = createQPredicateBuildMethodSignature().addModifiers(Modifier.ABSTRACT).build();
        var typeQPredicate = qFilteredConfig.name().nestedClass("QPredicate");
        var interfaceQPredicate = TypeSpec.interfaceBuilder(typeQPredicate)
            .addMethod(methodBuild)
            .build();

        TypeSpec classBuiltinPredicate;
        {
            var fieldName = ParameterSpec.builder(String.class, "name").build();
            var fieldArgs = ParameterSpec.builder(ParameterizedTypeName.get(List.class, String.class), "args").build();

            String varCaptureName = "captureName";
            var methodBuildImpl = createQPredicateBuildMethodSignature()
                .addAnnotation(Override.class)
                .addStatement("var $N = $N.$N()", varCaptureName, paramPredicateRegistry, typedQueryConfig.predicateRegistryConfig().methodRequestBuiltInQueryCapture())
                .addStatement(CodeBlock.builder()
                    .add("$N\n", paramQueryStringBuilder)
                    .add(".append('@').append($N)\n", varCaptureName)
                    .add(".append(\" (\")\n")
                    .add(".append('#').append($N).append('?')\n", fieldName)
                    .add(".append(' ')\n")
                    .add(".append('@').append($N)", varCaptureName)
                    .build()
                )
                .addStatement("$N.forEach(a -> $N.append(' ').append($N(a)))", fieldArgs, paramQueryStringBuilder, typedQueryConfig.qNodeImplConfig().methodCreateStringLiteral())
                .addStatement("$N.append(')')", paramQueryStringBuilder)
                .build();

            classBuiltinPredicate = TypeSpec.recordBuilder(qFilteredConfig.classBuiltinPredicate())
                .recordConstructor(canonicalRecordConstructor(fieldName, fieldArgs))
                .addSuperinterface(typeQPredicate)
                .addMethod(methodBuildImpl)
                .build();
        }

        TypeSpec classCustomPredicate;
        {
            var fieldPredicate = ParameterSpec.builder(
                ParameterizedTypeName.get(ClassName.get(Predicate.class), ParameterizedTypeName.get(ClassName.get(Stream.class), codeGenHelper.typedNodeConfig().className())),
                "predicate"
            ).build();

            String varPredicateName = "predicateName";
            String varCaptureName = "captureName";
            var methodBuildImpl = createQPredicateBuildMethodSignature()
                .addAnnotation(Override.class)
                .addStatement("var $N = $N.$N($N)", varPredicateName, paramPredicateRegistry, typedQueryConfig.predicateRegistryConfig().methodRegisterCustomPredicate(), fieldPredicate)
                .addStatement("var $N = $N", varCaptureName, varPredicateName)
                .addStatement(CodeBlock.builder()
                    .add("$N\n", paramQueryStringBuilder)
                    .add(".append('@').append($N)\n", varCaptureName)
                    .add(".append(\" (\")\n")
                    .add(".append('#')\n")
                    .add(".append($N)\n", varPredicateName)
                    .add("// Don't add any predicate args; when evaluating predicate it will get the corresponding capture based on the predicate name\n")
                    .add(".append(\"?)\")")
                    .build()
                )
                .build();

            classCustomPredicate = TypeSpec.recordBuilder(qFilteredConfig.classCustomPredicate())
                .recordConstructor(canonicalRecordConstructor(fieldPredicate))
                .addSuperinterface(typeQPredicate)
                .addMethod(methodBuildImpl)
                .build();
        }

        var fieldNode = FieldSpec.builder(typeQNodeImpl, "node", Modifier.PRIVATE, Modifier.FINAL).build();
        var fieldPredicate = FieldSpec.builder(typeQPredicate, "predicate", Modifier.PRIVATE, Modifier.FINAL).build();

        var constructor = createInitializingConstructor(fieldNode, fieldPredicate);

        var methodBuildQuery = createBuildQueryImplOverride()
            .addComment("To avoid any ambiguity wrap the whole node in a group")
            .addStatement("$N.append('(')", paramQueryStringBuilder)
            .addStatement(createDelegatingBuildQueryCall(fieldNode.name()))
            .addStatement("$N.append(' ')", paramQueryStringBuilder)
            .addStatement("$N.$N($N, $N)", fieldPredicate, methodBuild.name(), paramQueryStringBuilder, paramPredicateRegistry)
            .addStatement("$N.append(')')", paramQueryStringBuilder)
            .build();

        return TypeSpec.classBuilder(qFilteredConfig.name())
            .addModifiers(Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL)
            .addTypeVariable(typeVarCollector)
            .addTypeVariable(typeVarNodeBound)
            .superclass(typeQNodeImpl)
            // Implement `QCapturable` to also allow capturing, in addition to filtering
            .addSuperinterface(typeQCapturable)
            .addType(interfaceQPredicate)
            .addType(classBuiltinPredicate)
            .addType(classCustomPredicate)
            .addField(fieldNode)
            .addField(fieldPredicate)
            .addMethod(constructor)
            .addMethod(methodBuildQuery)
            .build();
    }

    private TypeSpec generateInterfaceQCapturable() {
        var qCapturableConfig = typedQueryConfig.qCapturableConfig();
        var qNodeImplConfig = typedQueryConfig.qNodeImplConfig();
        var typeVarNode = this.typeVarNodeBound;

        String paramCaptureHandler = "captureHandler";
        var methodCaptured = MethodSpec.methodBuilder(qCapturableConfig.methodCaptured())
            .addModifiers(Modifier.PUBLIC, Modifier.DEFAULT)
            .returns(typeQNode)
            .addParameter(
                ParameterizedTypeName.get(typedQueryConfig.captureHandlerConfig().name(), typeVarCollector, typeVarNode),
                paramCaptureHandler
            )
            .addJavadoc("Specifies that matching nodes should be captured during query execution and provided to the given capture handler.")
            .addJavadoc(TreeSitterDoc.CAPTURE.createJavadocSee())
            .addStatement(createNonNullCheck(paramCaptureHandler))
            .addStatement("return new $T<>($T.$N(this), $N)", typedQueryConfig.classQCaptured(), qNodeImplConfig.name(), qNodeImplConfig.methodFromNode(), paramCaptureHandler)
            .build();

        return TypeSpec.interfaceBuilder(qCapturableConfig.name())
            .addModifiers(Modifier.PUBLIC, Modifier.SEALED)
            .addTypeVariable(typeVarCollector)
            .addTypeVariable(typeVarNode)
            .addSuperinterface(ParameterizedTypeName.get(typedQueryConfig.qFilterableConfig().name(), typeVarCollector, typeVarNode))
            .addJavadoc("Allows capturing a node and accessing it during query execution. See the {@link $T} documentation for more information.", typedQueryConfig.name())
            .addMethod(methodCaptured)
            .build();
    }

    private TypeSpec generateClassQCaptured() {
        var fieldNode = FieldSpec.builder(typeQNodeImpl, "node", Modifier.PRIVATE, Modifier.FINAL).build();
        var fieldCaptureHandler = FieldSpec.builder(
            ParameterizedTypeName.get(typedQueryConfig.captureHandlerConfig().name(), typeVarCollector, unboundedWildcard()),
            "captureHandler",
            Modifier.PRIVATE, Modifier.FINAL
        ).build();

        var constructor = createInitializingConstructor(fieldNode, fieldCaptureHandler);

        String varCaptureName = "captureName";
        var methodBuildQuery = createBuildQueryImplOverride()
            .addStatement(createDelegatingBuildQueryCall(fieldNode.name()))
            .addStatement("var $N = $N.$N($N)", varCaptureName, paramCaptureRegistry, typedQueryConfig.captureRegistryConfig().methodRegisterHandler(), fieldCaptureHandler)
            .addStatement("$N.append(\" @\").append($N)", paramQueryStringBuilder, varCaptureName)
            .build();

        return TypeSpec.classBuilder(typedQueryConfig.classQCaptured())
            .addModifiers(Modifier.PRIVATE, Modifier.STATIC)
            .addTypeVariable(typeVarCollector)
            .addTypeVariable(typeVarNodeBound)
            // Do not use 'quantifiable' as superclass, because quantifier should be applied before capturing
            .superclass(typeQNodeImpl)
            .addField(fieldNode)
            .addField(fieldCaptureHandler)
            .addMethod(constructor)
            .addMethod(methodBuildQuery)
            .build();
    }

    private TypeSpec generateQCapturableQuantifiable() {
        var qQuantifiableConfig = typedQueryConfig.qQuantifiableConfig();

        // Package-private constructor, to prevent user code from accessing it
        var constructor = MethodSpec.constructorBuilder().build();

        var typeQQuantified = ParameterizedTypeName.get(typedQueryConfig.qQuantifiedConfig().name(), typeVarCollector, typeVarNode);
        String paramNode = "node";
        // Helper method because the `super` methods declare `QNode` as return type but actually return the internal class `QQuantified`
        var methodAsQuantified = MethodSpec.methodBuilder("asQuantified")
            .addModifiers(Modifier.PRIVATE, Modifier.STATIC)
            .addTypeVariable(typeVarCollector)
            .addTypeVariable(typeVarNode)
            .returns(typeQQuantified)
            .addParameter(typeQNode, paramNode)
            .addStatement("return ($T) $N", typeQQuantified, paramNode)
            .build();

        // Override methods to return `QCapturable` instead of just `QNode`
        var typeCapturableQuantified = typedQueryConfig.classQCapturableQuantified();
        var methodZeroOrMore = MethodSpec.methodBuilder(qQuantifiableConfig.methodZeroOrMore())
            .addAnnotation(Override.class)
            .addModifiers(Modifier.PUBLIC)
            .returns(typeQCapturable)
            .addStatement("return new $T<>($N(super.$N()))", typeCapturableQuantified, methodAsQuantified, qQuantifiableConfig.methodZeroOrMore())
            .build();

        var methodOneOrMore = MethodSpec.methodBuilder(qQuantifiableConfig.methodOneOrMore())
            .addAnnotation(Override.class)
            .addModifiers(Modifier.PUBLIC)
            .returns(typeQCapturable)
            .addStatement("return new $T<>($N(super.$N()))", typeCapturableQuantified, methodAsQuantified, qQuantifiableConfig.methodOneOrMore())
            .build();

        var methodOptional = MethodSpec.methodBuilder(qQuantifiableConfig.methodOptional())
            .addAnnotation(Override.class)
            .addModifiers(Modifier.PUBLIC)
            .returns(typeQCapturable)
            .addStatement("return new $T<>($N(super.$N()))", typeCapturableQuantified, methodAsQuantified, qQuantifiableConfig.methodOptional())
            .build();

        return TypeSpec.classBuilder(typedQueryConfig.classQCapturableQuantifiable())
            // non-sealed but constructor is not publicly accessible
            .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT, Modifier.STATIC, Modifier.NON_SEALED)
            .addTypeVariable(typeVarCollector)
            .addTypeVariable(typeVarNodeBound)
            .superclass(typeQQuantifiable)
            .addSuperinterface(typeQCapturable)
            .addJavadoc("Allows both {@linkplain $T capturing} and {@linkplain $T quantifying} matching nodes.", typeQCapturable.rawType(), typeQQuantifiable.rawType())
            .addJavadoc("\nTo do both, first use one of the quantifying methods such as {@link #$N} and afterwards the capturing method {@link #$N}.", qQuantifiableConfig.methodZeroOrMore(), typedQueryConfig.qCapturableConfig().methodCaptured())
            .addJavadoc("\nCalling the methods in the opposite order is not possible.")
            .addMethod(constructor)
            .addMethod(methodAsQuantified)
            .addMethod(methodZeroOrMore)
            .addMethod(methodOneOrMore)
            .addMethod(methodOptional)
            .build();
    }

    private TypeSpec generateQCapturableQuantified() {
        var qQuantifiedConfig = typedQueryConfig.qQuantifiedConfig();

        var typeQuantified = ParameterizedTypeName.get(qQuantifiedConfig.name(), typeVarCollector, typeVarNode);
        String paramQuantifiedNode = "quantifiedNode";
        var constructor = MethodSpec.constructorBuilder()
            .addParameter(typeQuantified, paramQuantifiedNode)
            // Access fields of node and pass them to super constructor
            .addStatement("super($N.$N, $N.$N)", paramQuantifiedNode, qQuantifiedConfig.fieldNode(), paramQuantifiedNode, qQuantifiedConfig.fieldQuantifier())
            .build();

        return TypeSpec.classBuilder(typedQueryConfig.classQCapturableQuantified())
            .addModifiers(Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL)
            .addTypeVariable(typeVarCollector)
            .addTypeVariable(typeVarNodeBound)
            .superclass(typeQuantified)
            .addSuperinterface(typeQCapturable)
            .addMethod(constructor)
            .build();
    }

    /**
     * Data for the query builder method for a user-defined node type.
     *
     * @param methodName
     *      name of the builder method to generate
     * @param qTypeName
     *      class name of the query builder class which corresponds to the node type
     * @param nodeType
     *      node type name, as it appears in  {@code node-types.json}
     * @see #generateBuilderClass(List)
     */
    public record QTypedNodeBuilderMethodData(String methodName, ClassName qTypeName, String nodeType) {
    }

    private MethodSpec createBuilderAlternationMethod(boolean typed) {
        var qNodeImplConfig = typedQueryConfig.qNodeImplConfig();
        var typeVarNode = typed ? this.typeVarNodeBound : this.typeVarNode;

        String paramNodes = "nodes";
        var methodBuilder = MethodSpec.methodBuilder(typedQueryConfig.builderConfig().methodAlternation())
            .addAnnotation(SafeVarargs.class)
            .addAnnotation(SUPPRESS_WARNINGS_VARARGS)
            .addModifiers(Modifier.PUBLIC, Modifier.FINAL)
            .addTypeVariable(typeVarNode)
            .returns(typed
                ? ParameterizedTypeName.get(typedQueryConfig.classQCapturableQuantifiable(), typeVarCollector, typeVarNode)
                : typeQQuantifiable
            )
            .addParameter(
                ArrayTypeName.of(ParameterizedTypeName.get(
                    // Must also enforce `QCapturableQuantifiable` here; just requiring `N extends TypedNode` (`typeVarNodeBound`)
                    // is not enough because wildcard-like nodes such as ERROR nodes can satisfy this even though they should not
                    // be capturable for the type-safe API
                    typed ? typedQueryConfig.qCapturableConfig().name() : typedQueryConfig.qNodeConfig().name(),
                    typeVarCollector,
                    WildcardTypeName.subtypeOf(typeVarNode)
                )),
                paramNodes
            )
            .varargs()
            .addJavadoc("Provides a query builder which matches any of the given nodes.");

        if (typed) {
            methodBuilder.addJavadoc("\n\n<p>This overload takes query nodes which are capturable, and returns a query node which is capturable itself as well.");
        }

        return methodBuilder
            .addJavadoc(TreeSitterDoc.ALTERNATION.createJavadocSee())
            .addStatement("return new $T<>($T.$N($N))", typedQueryConfig.classQAlternation(typed), qNodeImplConfig.name(), qNodeImplConfig.methodListOf(), paramNodes)
            .build();
    }

    /**
     * Generates the {@code Builder} class which is the main API for obtaining query builder objects.
     *
     * @param nodeBuilderMethodData data for the builder methods which should be generated for the user-defined node types
     */
    public TypeSpec generateBuilderClass(List<QTypedNodeBuilderMethodData> nodeBuilderMethodData) {
        var builderConfig = typedQueryConfig.builderConfig();

        var typeBuilder = TypeSpec.classBuilder(builderConfig.name())
            // For now don't make this class `final` to allow users to subclass it and add custom builder methods?
            .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
            .addTypeVariable(typeVarCollector);

        typeBuilder
            .addJavadoc("Provides convenience methods for obtaining typed query builder objects.")
            .addJavadoc("\n\n<p>The methods are non-static to help with type inference for the {@code <$T>} type variable.", typeVarCollector)
            .addJavadoc("\nThis builder as well as all returned builder objects are immutable. That means when calling any methods")
            .addJavadoc("\non the query builder objects, the result must not be discarded, otherwise the call has no effect.")
            .addJavadoc("\n\n<p>The expected usage looks like this:")
            .addJavadoc("\n{@snippet lang=java :")
            .addJavadoc("\nvar q = new $T.$N<MyCollector>();", typedQueryConfig.name(), builderConfig.name().simpleName())
            .addJavadoc("\nvar typedQuery = q.$N(", builderConfig.methodAlternation())
            .addJavadoc("\n    q.$N(),", builderConfig.methodErrorNode())
            .addJavadoc("\n    q.nodeMyCustomNode().$N((myCollector, node) -> ...)", typedQueryConfig.qCapturableConfig().methodCaptured())
            .addJavadoc("\n  ).$N(" + (codeGenHelper.languageUtilsConfig() == null ? "language" : "") + ")", typedQueryConfig.qNodeConfig().methodBuildQuery())
            .addJavadoc("\n}");

        typeBuilder
            .addJavadoc("\n\n<h2>General builder methods</h2>")
            .addJavadoc("\n<ul>")
            .addJavadoc("\n<li>{@link #$N}", builderConfig.methodUnnamedNode())
            .addJavadoc("\n<li>{@link #$N}, {@link #$N}", builderConfig.methodAnyNamedNode(), builderConfig.methodAnyNode())
            .addJavadoc("\n<li>{@link #$N}", builderConfig.methodErrorNode())
            .addJavadoc("\n<li>{@link #$N}", builderConfig.methodMissingNode())
            .addJavadoc("\n<li>{@link #$N}", builderConfig.methodGroup())
            .addJavadoc("\n<li>{@link #$N}", builderConfig.methodAlternation())
            .addJavadoc("\n</ul>");

        typeBuilder
            .addJavadoc("\n\n<h2>Node type builder methods</h2>")
            .addJavadoc("Additionally for each node type defined in the Tree-sitter grammar a dedicated query builder method exists:");
        // TODO: Should generate HTML table instead of list?
        typeBuilder.addJavadoc("\n<ul>");
        // TODO: Sort these type names lexicographically (maybe already in `CodeGenerator`?)? It seems tree-sitter only emits them partially sorted;
        //   see also TODO in CodeGenHelper#addJavadocTypeMapping
        for (var nodeData : nodeBuilderMethodData) {
            typeBuilder.addJavadoc("\n<li>{@link #$N $L}", nodeData.methodName(), CodeGenHelper.escapeJavadocText(nodeData.nodeType()));
        }
        typeBuilder.addJavadoc("\n</ul>");

        typeBuilder.addJavadoc("\n@param <$T> type of the user-defined 'collector' which processes query captures; see the {@link $T} documentation", typeVarCollector, typedQueryConfig.name());

        // Explicit public constructor
        var constructor = MethodSpec.constructorBuilder().addModifiers(Modifier.PUBLIC).build();
        typeBuilder.addMethod(constructor);

        var javadocUnboundN = CodeBlock.of("\n\n<p>The node type variable {@code <$T>} is unbound to allow using this query node at any position in the query.", typeVarNode);

        {
            var qUnnamedNodeConfig = typedQueryConfig.qUnnamedNodeConfig();

            String paramNodeType = "nodeType";
            var methodUnnamedNode = MethodSpec.methodBuilder(builderConfig.methodUnnamedNode())
                .addModifiers(Modifier.PUBLIC)
                .addTypeVariable(typeVarNode)
                .returns(typeQQuantifiable)
                .addParameter(String.class, paramNodeType)
                .addJavadoc("Provides a query builder for an unnamed node.")
                .addJavadoc(javadocUnboundN)
                .addJavadoc("\n@see #$N($T, $T)", builderConfig.methodUnnamedNode(), String.class, String.class)
                .addJavadoc(TreeSitterDoc.ANONYMOUS_NODE.createJavadocSee())
                .addStatement("return new $T<>(null, $N)", qUnnamedNodeConfig.name(), paramNodeType)
                .build();
            typeBuilder.addMethod(methodUnnamedNode);

            String paramSupertype = "supertype";
            var methodUnnamedNodeWithSupertype = MethodSpec.methodBuilder(builderConfig.methodUnnamedNode())
                .addModifiers(Modifier.PUBLIC)
                .addTypeVariable(typeVarNode)
                .returns(typeQQuantifiable)
                .addParameter(String.class, paramSupertype)
                .addParameter(String.class, paramNodeType)
                .addJavadoc("Provides a query builder for an unnamed node with supertype.")
                .addJavadoc("\n\n<p>This can be useful when an unnamed node can appear in multiple contexts and only one of them should be matched.")
                .addJavadoc("\nFor example in Java code a single {@code ';'} can represent an \"empty statement\".")
                .addJavadoc("\nTo match only such usage and ignore all other occurrences {@code $N(\"statement\", \";\")} could be used.", builderConfig.methodUnnamedNode())
                .addJavadoc(javadocUnboundN)
                .addJavadoc(TreeSitterDoc.ANONYMOUS_NODE.createJavadocSee())
                .addJavadoc(TreeSitterDoc.SUPERTYPE_NODE.createJavadocSee())
                .addStatement(createNonNullCheck(paramSupertype))
                .addStatement("return new $T<>($N, $N)", qUnnamedNodeConfig.name(), paramSupertype, paramNodeType)
                .build();
            typeBuilder.addMethod(methodUnnamedNodeWithSupertype);
        }
        {
            var qWildcardNodeConfig = typedQueryConfig.qWildcardNodeConfig();
            var typeQWildcardNode = qWildcardNodeConfig.name();
            var typeQWildcardNodeParameterized = ParameterizedTypeName.get(typeQWildcardNode, typeVarCollector, typeVarNode);

            var methodAnyNamedNode = MethodSpec.methodBuilder(builderConfig.methodAnyNamedNode())
                .addAnnotation(SUPPRESS_WARNINGS_UNCHECKED)
                .addModifiers(Modifier.PUBLIC)
                .addTypeVariable(typeVarNode)
                .returns(typeQQuantifiable)
                .addJavadoc("Provides a query builder for a wildcard node which matches any named node.")
                .addJavadoc(javadocUnboundN)
                .addJavadoc(TreeSitterDoc.WILDCARD_NODE.createJavadocSee())
                .addStatement("return ($T) $T.$N", typeQWildcardNodeParameterized, typeQWildcardNode, qWildcardNodeConfig.constantNamed())
                .build();
            typeBuilder.addMethod(methodAnyNamedNode);

            var methodAnyNode = MethodSpec.methodBuilder(builderConfig.methodAnyNode())
                .addAnnotation(SUPPRESS_WARNINGS_UNCHECKED)
                .addModifiers(Modifier.PUBLIC)
                .addTypeVariable(typeVarNode)
                .returns(typeQQuantifiable)
                .addJavadoc("Provides a query a builder for a wildcard node which matches any node (named or unnamed).")
                .addJavadoc(javadocUnboundN)
                .addJavadoc(TreeSitterDoc.WILDCARD_NODE.createJavadocSee())
                .addStatement("return ($T) $T.$N", typeQWildcardNodeParameterized, typeQWildcardNode, qWildcardNodeConfig.constantNamedOrUnnamed())
                .build();
            typeBuilder.addMethod(methodAnyNode);
        }

        {
            var qErrorNodeConfig = typedQueryConfig.qErrorNodeConfig();
            var typeQErrorNode = qErrorNodeConfig.name();
            var typeQErrorNodeParameterized = ParameterizedTypeName.get(typeQErrorNode, typeVarCollector, typeVarNode);
            var methodErrorNode = MethodSpec.methodBuilder(builderConfig.methodErrorNode())
                .addAnnotation(SUPPRESS_WARNINGS_UNCHECKED)
                .addModifiers(Modifier.PUBLIC)
                .addTypeVariable(typeVarNode)
                .returns(typeQQuantifiable)
                .addJavadoc("Provides a query builder which matches any ERROR node.")
                .addJavadoc(javadocUnboundN)
                .addJavadoc(TreeSitterDoc.ERROR_NODE.createJavadocSee())
                .addStatement("return ($T) $T.$N", typeQErrorNodeParameterized, typeQErrorNode, qErrorNodeConfig.constantInstance())
                .build();
            typeBuilder.addMethod(methodErrorNode);
        }

        {
            var qMissingNodeConfig = typedQueryConfig.qMissingNodeConfig();
            var typeQMissingNode = qMissingNodeConfig.name();
            var typeQMissingNodeParameterized = ParameterizedTypeName.get(typeQMissingNode, typeVarCollector, typeVarNode);
            var methodMissingNode = MethodSpec.methodBuilder(builderConfig.methodMissingNode())
                .addAnnotation(SUPPRESS_WARNINGS_UNCHECKED)
                .addModifiers(Modifier.PUBLIC)
                .addTypeVariable(typeVarNode)
                .returns(typeQQuantifiable)
                .addJavadoc("Provides a query builder which matches any MISSING node.")
                .addJavadoc(javadocUnboundN)
                .addJavadoc(TreeSitterDoc.MISSING_NODE.createJavadocSee())
                .addStatement("return ($T) $T.$N", typeQMissingNodeParameterized, typeQMissingNode, qMissingNodeConfig.constantAny())
                .build();
            typeBuilder.addMethod(methodMissingNode);
        }

        {
            var qNodeImplConfig = typedQueryConfig.qNodeImplConfig();
            String paramNodes = "nodes";
            var methodGroup = MethodSpec.methodBuilder(builderConfig.methodGroup())
                .addAnnotation(SafeVarargs.class)
                .addAnnotation(SUPPRESS_WARNINGS_VARARGS)
                .addModifiers(Modifier.PUBLIC, Modifier.FINAL)
                .addTypeVariable(typeVarNode)
                .returns(typeQQuantifiable)
                .addParameter(
                    ArrayTypeName.of(ParameterizedTypeName.get(typedQueryConfig.qNodeConfig().name(), typeVarCollector, WildcardTypeName.subtypeOf(typeVarNode))),
                    paramNodes
                )
                .varargs()
                .addJavadoc("Provides a query builder which matches a group of multiple sibling nodes.")
                .addJavadoc(TreeSitterDoc.GROUP.createJavadocSee())
                .addStatement("return new $T<>($T.$N($N))", typedQueryConfig.classQGroup(), qNodeImplConfig.name(), qNodeImplConfig.methodListOf(), paramNodes)
                .build();
            typeBuilder.addMethod(methodGroup);
        }

        typeBuilder.addMethod(createBuilderAlternationMethod(false));
        typeBuilder.addMethod(createBuilderAlternationMethod(true));

        for (var builderMethodData : nodeBuilderMethodData) {
            var method = MethodSpec.methodBuilder(builderMethodData.methodName())
                .addModifiers(Modifier.PUBLIC)
                .returns(ParameterizedTypeName.get(builderMethodData.qTypeName(), typeVarCollector))
                .addJavadoc("Provides a query builder which matches nodes of type $L.", CodeGenHelper.createJavadocCodeTag(builderMethodData.nodeType))
                .addStatement("return new $T<>()", builderMethodData.qTypeName())
                .build();
            typeBuilder.addMethod(method);
        }

        return typeBuilder.build();
    }

    /**
     * Generates all common {@code QNode} types.
     */
    public List<TypeSpec> generateTypes() {
        return List.of(
            generateInterfaceQNode(),
            generateClassQNodeImpl(),
            generateClassQQuantifiable(),
            generateClassQQuantified(),
            generateClassQGroup(),
            generateClassQAlternation(false),
            generateClassQAlternation(true),
            generateClassQUnnamedNode(),
            generateClassQWildcardNode(),
            generateClassQErrorNode(),
            generateClassQMissingNode(),
            generateInterfaceQFilterable(),
            generateClassQFiltered(),
            generateInterfaceQCapturable(),
            generateClassQCaptured(),
            generateQCapturableQuantifiable(),
            generateQCapturableQuantified()
        );
    }
}
