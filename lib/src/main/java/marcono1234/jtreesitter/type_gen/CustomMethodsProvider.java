package marcono1234.jtreesitter.type_gen;

import java.util.List;
import java.util.Optional;
import java.util.SequencedMap;

/**
 * Provides the configuration for custom methods to be added to the generated classes.
 *
 * <p>The methods are generated as instance methods which just delegate to a user-defined 'receiver
 * method' which contains the actual implementation. The main advantage of this is that the generated
 * methods can directly be called on the {@code TypedTree} or {@code TypedNode} objects, making it
 * easier to use than having to pass those objects to a separate method.
 *
 * <p>The receiver method is always called with {@code this} as first argument. In addition to that
 * {@link MethodData#parameters()} can be defined which are passed as-is to the receiver method, and
 * {@link MethodData#additionalArguments()} which can for example be used to tell apart the different
 * call sites of the receiver method (in case the same receiver method is used at multiple call sites).
 *
 * <p>This is the structure of the generated method:
 * {@snippet lang=java :
 * class MyNode {
 *     // JAVADOC
 *     public <TYPE_VARS> RETURN_TYPE NAME(PARAMS) {
 *         return RECEIVER.METHOD(this, PARAMS, ADDITIONAL_ARGS);
 *     }
 * }
 * }
 * For example:
 * {@snippet lang=java :
 * class MyNode {
 *     public String customMethod(int i) {
 *         return CustomMethods.myMethod(this, i, "additional");
 *     }
 * }
 * }
 *
 * <p>The default implementations of the provider methods return empty lists, therefore not
 * generating any custom methods.
 *
 * <p><b>Important:</b> In some cases custom methods will be inherited, for example the custom methods
 * defined with {@link #forTypedNode()} or those defined with {@link #forNodeType(String)} for a supertype
 * node type. Ensure that there is no method signature conflict for the custom methods, or ensure that the
 * custom methods (intentionally) override each other.<br>
 * Similarly make sure that the custom methods do not conflict with or override by accident any of the methods
 * which are generated by default.
 */
public interface CustomMethodsProvider {
    /**
     * @param name
     *      name of the custom method
     * @param typeVariables
     *      type variables of the custom method (can be empty)
     * @param parameters
     *      parameters of the custom method; will be passed as-is to the receiver method
     * @param returnType
     *      return type of the custom method; empty {@code Optional} for {@code void}
     * @param javadoc
     *      Javadoc text of the custom method<br>
     *      Note that the Javadoc will be added as is and no additional processing will be performed.
     *      It should therefore use line breaks to wrap long lines, and for Javadoc references such as
     *      in {@code {@link ...}} tags qualified type names should be used.
     * @param receiverType
     *      type declaring the {@code receiverMethod}
     * @param receiverMethod
     *      name of the method of the receiver type to which the custom method will delegate the call<br>
     *      The method should be {@code static} and be accessible by the generated code.
     * @param additionalArguments
     *      optional additional arguments to pass to the receiver method<br>
     *      These can for example be used to tell apart the different call sites of the receiver method,
     *      in case it is called by multiple custom methods.
     */
    record MethodData(
        String name,
        List<JavaTypeVariable> typeVariables,
        SequencedMap<String, JavaType> parameters,
        Optional<JavaType> returnType,
        Optional<String> javadoc,
        // TODO: Maybe here and everywhere else rename 'receiver' to 'target'?
        TypeName receiverType,
        String receiverMethod,
        // TODO: How useful are these `additionalArguments` really? Are they really worth it?
        List<JavaLiteral> additionalArguments
    ) {}

    /**
     * Custom methods for the generated {@code TypedTree} class.
     *
     * <p>{@code TypedTree} is a type-safe wrapper around a jtreesitter {@code Tree}. The class is only generated if
     * the grammar root node type is specified.
     */
    default List<MethodData> forTypedTree() {
        return List.of();
    }

    /**
     * Custom methods for the generated {@code TypedNode} interface.
     *
     * <p>{@code TypedNode} is the base type for all typed node classes, which wrap the underlying jtreesitter {@code Node}.
     */
    default List<MethodData> forTypedNode() {
        return List.of();
    }

    /**
     * Custom methods for the generated class or interface for the given node type.
     *
     * @param nodeType name of the node type, as defined in the Tree-sitter grammar
     */
    default List<MethodData> forNodeType(String nodeType) {
        return List.of();
    }

    /**
     * Custom methods for the generated interface for the children types of the given node type.
     *
     * <p>That interface for the children is generated as common superinterface when multiple possible children types
     * are defined by the Tree-sitter grammar, see also {@link NameGenerator#generateChildrenTypesName(String, List)}.
     *
     * @param parentNodeType
     *      name of the parent node type, as defined in the Tree-sitter grammar
     * @param childrenNodeTypes
     *      names of the children node types
     */
    default List<MethodData> forNodeChildrenType(String parentNodeType, List<String> childrenNodeTypes) {
        return List.of();
    }
    // TODO Also for children token type? (currently unused, see also `NameGenerator#generateChildrenTokenTypeName`)

    /**
     * Custom methods for the generated interface for the field types of the given node type field.
     *
     * <p>That interface for the field is generated as common superinterface when multiple possible field types
     * are defined by the Tree-sitter grammar, see also {@link NameGenerator#generateFieldTypesName(String, String)}.
     *
     * @param parentNodeType
     *      name of the parent node type, as defined in the Tree-sitter grammar
     * @param fieldName
     *      name of the field
     */
    default List<MethodData> forNodeFieldType(String parentNodeType, String fieldName) {
        return List.of();
    }
    // TODO Also for field token type? (see also `NameGenerator#generateFieldTokenTypeName`)
}
