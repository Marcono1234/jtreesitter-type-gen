package marcono1234.jtreesitter.type_gen;

import marcono1234.jtreesitter.type_gen.internal.JavaNameValidator;

import javax.annotation.processing.Generated;
import java.time.Instant;
import java.util.List;
import java.util.Objects;
import java.util.Optional;

/**
 * General code generation config, not specific to a {@code node-types.json} file or a language.
 *
 * @param packageName
 *      Java package name the generated code should use; will create the corresponding subdirectories
 *      in the output directory.
 * @param nullableAnnotationTypeName
 *      Qualified name of the {@code @Nullable} annotation to use in the generated code, can for example
 *      be {@link TypeName#JSPECIFY_NULLABLE_ANNOTATION}.<br>
 *      If empty, no annotation is used and instead {@link Optional} is used in the generated code for
 *      nullable values.
 * @param nullMarkedPackageAnnotationTypeName
 *      Qualified name of the {@code @NullMarked} annotation to use in the generated code, can for example
 *      be {@link TypeName#JSPECIFY_NULLMARKED_ANNOTATION}.<br>
 *      If specified, a {@code package-info.java} file will be generated which is annotated with the annotation.
 *      This indicates to IDEs and tools that all type references in the package should be treated as non-null
 *      unless explicitly marked nullable.<br>
 *      This option can only be used if {@code nullableAnnotationTypeName} is specified as well.
 * @param nonEmptyTypeName
 *      Simple type name of an annotation type to be generated and used for methods which return non-empty
 *      collections. The annotation is mainly intended for documentation purposes. For example {@code NonEmpty}.
 * @param childTypeAsTopLevel
 *      Whether to generate Java types for node children as top-level classes.
 * @param typedNodeSuperinterface
 *      Custom interface type the generated {@code TypedNode} interface should extend.<br>
 *      That interface must not define any abstract methods other than those which are generated by {@code TypedNode}
 *      by default anyway (which are then effectively overridden by {@code TypedNode}). And it can then define
 *      additional methods with {@code default} implementation which delegate to those abstract methods.
 * @param nameGenerator
 *      Determines the names for fields, methods, classes, ... in the generated code.
 * @param generateFindNodesMethods
 *      Whether to generate {@code findNodes(...)} methods for the typed node classes.<br>
 *      These methods allow obtaining all instances of a node type starting at a given node. Disabling this can be
 *      useful to reduce the size of the generated code when it is known that these methods will not be used.
 *      For example when the tree is always traversed manually or when the more powerful {@linkplain #typedQueryNameGenerator() 'typed query'}
 *      is used instead.
 * @param typedQueryNameGenerator
 *      Determines the names for the generated 'typed query' code. The generated code allows building a Tree-sitter
 *      query and consuming captures, both in a type-safe way.<br>
 *      If an empty {@link Optional} is given, no 'typed query' code will be generated.
 * @param generatedAnnotationConfig
 *      Configuration for {@code @Generated} annotations placed on generated classes; empty if such annotations
 *      should be not added.
 */
// Note: Internally this library uses `@Nullable`, but externally it uses `Optional`
public record CodeGenConfig(
    // TODO: Maybe should put package name as CodeGenerator#generate argument instead of config value since it is likely
    //   related to the `node-types.json`, e.g. the package name contains the language name
    String packageName,
    // TODO: For Nullable annotation maybe allow configuring whether to put on method, or on type
    Optional<TypeName> nullableAnnotationTypeName,
    Optional<TypeName> nullMarkedPackageAnnotationTypeName,
    // TODO: Maybe make 'non empty' annotation optional as well, in case users don't want it?
    String nonEmptyTypeName,
    ChildTypeAsTopLevel childTypeAsTopLevel,
    Optional<TypeName> typedNodeSuperinterface,
    NameGenerator nameGenerator,
    // This config for `findNodes()` mainly exists at the request of users (see https://github.com/Marcono1234/jtreesitter-type-gen/issues/4)
    boolean generateFindNodesMethods,
    Optional<TypedQueryNameGenerator> typedQueryNameGenerator,
    Optional<GeneratedAnnotationConfig> generatedAnnotationConfig
) {
    public CodeGenConfig {
        JavaNameValidator.checkPackageName(packageName);

        Objects.requireNonNull(nullableAnnotationTypeName);
        Objects.requireNonNull(nullMarkedPackageAnnotationTypeName);
        if (nullMarkedPackageAnnotationTypeName.isPresent() && nullableAnnotationTypeName.isEmpty()) {
            throw new IllegalArgumentException("Cannot use null-marked annotation when nullable annotation is not specified");
        }

        JavaNameValidator.checkTypeName(nonEmptyTypeName, false);
        Objects.requireNonNull(childTypeAsTopLevel);
        nameGenerator = validatingNameGenerator(nameGenerator);
        typedQueryNameGenerator = typedQueryNameGenerator.map(CodeGenConfig::validatingTypedQueryNameGenerator);
        Objects.requireNonNull(generatedAnnotationConfig);
    }

    /**
     * Whether to generate a top-level or a nested Java class for a node child type.
     */
    public enum ChildTypeAsTopLevel {
        /**
         * Never generate top-level Java classes for node child types, instead always generate nested Java classes for them.
         *
         * <p><b>Warning:</b> This can lead to "cyclic inheritance" compilation errors.
         */
        NEVER,
        /**
         * Always generate top-level Java classes for node child types.
         */
        ALWAYS,
        /**
         * Generate top-level Java classes for node child types as needed, to avoid "cyclic inheritance" compilation errors.
         * If not needed for a specific node child type, generate a nested Java class instead.
         */
        AS_NEEDED
    }

    /*
     * Note: `@Generated` is in the `javax.annotation.processing` package, which is actually for annotation processing,
     * but maybe it is fine nonetheless to use the annotation, even though code generation here is not doing annotation
     * processing
     */
    /**
     * Configuration for the {@code @Generated} annotation placed on the code.
     *
     * @param annotationType
     *      information about the annotation type, such as qualified type name and annotation element names
     * @param generationTime
     *      fixed time when the code was generated, useful for reproducible builds; if empty the current time is used
     * @param additionalInformation
     *      additional information to include in the {@code @Generated} annotation, can for example be the origin / version
     *      of the {@code node-types.json} file
     */
    public record GeneratedAnnotationConfig(GeneratedAnnotationType annotationType, Optional<Instant> generationTime, Optional<String> additionalInformation) {
        public GeneratedAnnotationConfig {
            Objects.requireNonNull(annotationType);
            Objects.requireNonNull(generationTime);
            Objects.requireNonNull(additionalInformation);
        }

        /**
         * Information about the annotation type to place on generated classes. {@link #JAVAX_GENERATED} can be used
         * in most cases, unless you want to specify a custom one.
         *
         * @param typeName
         *      qualified name of the annotation type, for example {@code com.example.Generated}
         * @param generatorElementName
         *      name of annotation type element of type {@code String} for storing the qualified name of the code
         *      generator; empty if not supported by this annotation type
         * @param dateElementName
         *      name of annotation type element of type {@code String} for storing the date when the code was
         *      generated; empty if not supported by this annotation type
         * @param commentsElementName
         *      name of annotation type element of type {@code String} for storing additional comments in the
         *      annotation; empty if not supported by this annotation type
         */
        // For use case of custom `@Generated`, see https://github.com/projectlombok/lombok/issues/1014
        public record GeneratedAnnotationType(TypeName typeName, Optional<String> generatorElementName, Optional<String> dateElementName, Optional<String> commentsElementName) {
            public GeneratedAnnotationType {
                Objects.requireNonNull(typeName);
                Objects.requireNonNull(generatorElementName);
                Objects.requireNonNull(dateElementName);
                Objects.requireNonNull(commentsElementName);
            }

            /**
             * Type {@link Generated javax.annotation.processing.Generated}
             */
            public static final GeneratedAnnotationType JAVAX_GENERATED = new GeneratedAnnotationType(TypeName.fromClass(Generated.class), Optional.of("value"), Optional.of("date"), Optional.of("comments"));
        }
    }

    private static String validateTypeName(String name) {
        JavaNameValidator.checkTypeName(name, false);
        return name;
    }

    private static String validateMemberName(String name) {
        JavaNameValidator.checkMemberName(name);
        return name;
    }

    /**
     * Wraps a name generator in a generator which validates that the generated names are valid Java names.
     */
    private static NameGenerator validatingNameGenerator(NameGenerator nameGenerator) {
        Objects.requireNonNull(nameGenerator);
        return new NameGenerator() {
            @Override
            public String generateJavaTypeName(String typeName) {
                return validateTypeName(nameGenerator.generateJavaTypeName(typeName));
            }

            @Override
            public String generateTypeNameConstant(String typeName) {
                return validateMemberName(nameGenerator.generateTypeNameConstant(typeName));
            }

            @Override
            public String generateTypeIdConstant(String typeName) {
                return validateMemberName(nameGenerator.generateTypeIdConstant(typeName));
            }

            @Override
            public String generateChildrenTypesName(String parentTypeName, List<String> childrenTypesNames) {
                return validateTypeName(nameGenerator.generateChildrenTypesName(parentTypeName, childrenTypesNames));
            }

            @Override
            public String generateChildrenTokenTypeName(String parentTypeName, List<String> tokenChildrenTypesNames) {
                return validateTypeName(nameGenerator.generateChildrenTokenTypeName(parentTypeName, tokenChildrenTypesNames));
            }

            @Override
            public String generateChildrenTokenName(String parentTypeName, String tokenType, int index) {
                return validateMemberName(nameGenerator.generateChildrenTokenName(parentTypeName, tokenType, index));
            }

            @Override
            public String generateChildrenGetterName(String parentTypeName, List<String> childrenTypesNames, boolean multiple, boolean required) {
                return validateMemberName(nameGenerator.generateChildrenGetterName(parentTypeName, childrenTypesNames, multiple, required));
            }

            @Override
            public String generateFieldNameConstant(String parentTypeName, String fieldName) {
                return validateMemberName(nameGenerator.generateFieldNameConstant(parentTypeName, fieldName));
            }

            @Override
            public String generateFieldIdConstant(String parentTypeName, String fieldName) {
                return validateMemberName(nameGenerator.generateFieldIdConstant(parentTypeName, fieldName));
            }

            @Override
            public String generateFieldTypesName(String parentTypeName, String fieldName) {
                return validateTypeName(nameGenerator.generateFieldTypesName(parentTypeName, fieldName));
            }

            @Override
            public String generateFieldTokenTypeName(String parentTypeName, String fieldName, List<String> tokenFieldTypesNames) {
                return validateTypeName(nameGenerator.generateFieldTokenTypeName(parentTypeName, fieldName, tokenFieldTypesNames));
            }

            @Override
            public String generateFieldTokenName(String parentTypeName, String fieldName, String tokenType, int index) {
                return validateMemberName(nameGenerator.generateFieldTokenName(parentTypeName, fieldName, tokenType, index));
            }

            @Override
            public String generateFieldGetterName(String parentTypeName, String fieldName, boolean multiple, boolean required) {
                return validateMemberName(nameGenerator.generateFieldGetterName(parentTypeName, fieldName, multiple, required));
            }

            @Override
            public Optional<String> generateNonNamedChildrenGetterName(String parentTypeName, boolean hasNamedChildren, boolean hasFields) {
                return nameGenerator.generateNonNamedChildrenGetterName(parentTypeName, hasNamedChildren, hasFields)
                    .map(CodeGenConfig::validateMemberName);
            }
        };
    }

    /**
     * Wraps a name generator in a generator which validates that the generated names are valid Java names.
     */
    private static TypedQueryNameGenerator validatingTypedQueryNameGenerator(TypedQueryNameGenerator nameGenerator) {
        Objects.requireNonNull(nameGenerator);
        return new TypedQueryNameGenerator() {
            @Override
            public String generateBuilderClassName(String typeName) {
                return validateTypeName(nameGenerator.generateBuilderClassName(typeName));
            }

            @Override
            public String generateBuilderMethodName(String typeName) {
                return validateMemberName(nameGenerator.generateBuilderMethodName(typeName));
            }

            @Override
            public String generateAsSubtypeMethodName(String typeName, String supertypeName) {
                return validateMemberName(nameGenerator.generateAsSubtypeMethodName(typeName, supertypeName));
            }

            @Override
            public String generateWithFieldMethodName(String parentTypeName, String fieldName) {
                return validateMemberName(nameGenerator.generateWithFieldMethodName(parentTypeName, fieldName));
            }

            @Override
            public String generateWithoutFieldMethodName(String parentTypeName, String fieldName) {
                return validateMemberName(nameGenerator.generateWithoutFieldMethodName(parentTypeName, fieldName));
            }

            @Override
            public String generateFieldTokenMethodName(String parentTypeName, String fieldName, List<String> tokenFieldTypesNames) {
                return validateMemberName(nameGenerator.generateFieldTokenMethodName(parentTypeName, fieldName, tokenFieldTypesNames));
            }

            @Override
            public String generateChildTokenMethodName(String parentTypeName, List<String> tokenChildrenTypesNames) {
                return validateMemberName(nameGenerator.generateChildTokenMethodName(parentTypeName, tokenChildrenTypesNames));
            }
        };
    }
}
