package marcono1234.jtreesitter.type_gen;

import marcono1234.jtreesitter.type_gen.internal.JavaNameValidator;

import javax.annotation.processing.Generated;
import java.time.Instant;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import java.util.function.Consumer;

/**
 * General code generation config, not specific to a {@code node-types.json} file or a language.
 *
 * <p><b>Tip:</b> Instead of using the constructor of this config class, prefer using {@link #builder(String)} to only specify
 * the data which differs from the default config, and to avoid experiencing breaking changes in case new config
 * parameters are added in the future.
 *
 * @param packageName
 *      Java package name the generated code should use; will create the corresponding subdirectories
 *      in the output directory.
 * @param nullableAnnotationTypeName
 *      Qualified name of the {@code @Nullable} annotation to use in the generated code, can for example
 *      be {@link TypeName#JSPECIFY_NULLABLE_ANNOTATION}.<br>
 *      If empty, no annotation is used and instead {@link Optional} is used in the generated code for
 *      nullable values.
 * @param nullMarkedPackageAnnotationTypeName
 *      Qualified name of the {@code @NullMarked} annotation to use in the generated code, can for example
 *      be {@link TypeName#JSPECIFY_NULLMARKED_ANNOTATION}.<br>
 *      If specified, a {@code package-info.java} file will be generated which is annotated with the annotation.
 *      This indicates to IDEs and tools that all type references in the package should be treated as non-null
 *      unless explicitly marked nullable.<br>
 *      This option can only be used if {@code nullableAnnotationTypeName} is specified as well.
 * @param nonEmptyTypeName
 *      Simple type name of an annotation type to be generated and used for methods which return non-empty
 *      collections. The annotation is mainly intended for documentation purposes. For example {@code NonEmpty}.
 * @param childTypeAsTopLevel
 *      Whether to generate Java types for node children as top-level classes.
 * @param typedNodeSuperinterface
 *      Custom interface type the generated {@code TypedNode} interface should extend.<br>
 *      That interface must not define any abstract methods other than those which are generated by {@code TypedNode}
 *      by default anyway (which are then effectively overridden by {@code TypedNode}). And it can then define
 *      additional methods with {@code default} implementation which delegate to those abstract methods.
 * @param nameGenerator
 *      Determines the names for fields, methods, classes, ... in the generated code.
 * @param generateFindNodesMethods
 *      Whether to generate {@code findNodes(...)} methods for the typed node classes.<br>
 *      These methods allow obtaining all instances of a node type starting at a given node. Disabling this can be
 *      useful to reduce the size of the generated code when it is known that these methods will not be used.
 *      For example when the tree is always traversed manually or when the more powerful {@linkplain #typedQueryNameGenerator() 'typed query'}
 *      is used instead.
 * @param typedQueryNameGenerator
 *      Determines the names for the generated 'typed query' code. The generated code allows building a Tree-sitter
 *      query and consuming captures, both in a type-safe way.<br>
 *      If an empty {@link Optional} is given, no 'typed query' code will be generated.
 * @param customMethodsProvider
 *      Provides the configuration for custom methods to be added to the generated classes.<br>
 *      If an empty {@link Optional} is given, no custom methods will be added.
 * @param generatedAnnotationConfig
 *      Configuration for {@code @Generated} annotations placed on generated classes; empty if such annotations
 *      should be not added.
 */
// Note: Internally this library uses `@Nullable`, but externally it uses `Optional`
public record CodeGenConfig(
    // TODO: Maybe should put package name as CodeGenerator#generate argument instead of config value since it is likely
    //   related to the `node-types.json`, e.g. the package name contains the language name
    String packageName,
    // TODO: For Nullable annotation maybe allow configuring whether to put on method, or on type
    Optional<TypeName> nullableAnnotationTypeName,
    Optional<TypeName> nullMarkedPackageAnnotationTypeName,
    // TODO: Maybe make 'non empty' annotation optional as well, in case users don't want it?
    String nonEmptyTypeName,
    ChildTypeAsTopLevel childTypeAsTopLevel,
    Optional<TypeName> typedNodeSuperinterface,
    NameGenerator nameGenerator,
    // This config for `findNodes()` mainly exists at the request of users (see https://github.com/Marcono1234/jtreesitter-type-gen/issues/4)
    boolean generateFindNodesMethods,
    Optional<TypedQueryNameGenerator> typedQueryNameGenerator,
    Optional<CustomMethodsProvider> customMethodsProvider,
    Optional<GeneratedAnnotationConfig> generatedAnnotationConfig
) {
    public CodeGenConfig {
        JavaNameValidator.checkPackageName(packageName);

        Objects.requireNonNull(nullableAnnotationTypeName);
        Objects.requireNonNull(nullMarkedPackageAnnotationTypeName);
        if (nullMarkedPackageAnnotationTypeName.isPresent() && nullableAnnotationTypeName.isEmpty()) {
            throw new IllegalArgumentException("Cannot use null-marked annotation when nullable annotation is not specified");
        }

        JavaNameValidator.checkTypeName(nonEmptyTypeName, false);
        Objects.requireNonNull(childTypeAsTopLevel);
        nameGenerator = validatingNameGenerator(nameGenerator);
        typedQueryNameGenerator = typedQueryNameGenerator.map(CodeGenConfig::validatingTypedQueryNameGenerator);
        Objects.requireNonNull(generatedAnnotationConfig);
    }

    /**
     * Creates a new builder for {@link CodeGenConfig}.
     *
     * @param packageName see {@link CodeGenConfig#packageName()}
     */
    public static Builder builder(String packageName) {
        Objects.requireNonNull(packageName);
        return new Builder(packageName);
    }

    /**
     * Builder for {@link CodeGenConfig}. The config instance can be created using {@link #build()}.
     *
     * <p>All builder methods modify the builder instance; the returned builder can be ignored and only exists as
     * convenience to allow method call chaining.
     *
     * <h2>Defaults</h2>
     * <ul>
     * <li>{@link CodeGenConfig#nullableAnnotationTypeName() nullableAnnotationTypeName}: <a href="https://jspecify.dev/">JSpecify</a> {@code @Nullable}
     * <li>{@link CodeGenConfig#nullMarkedPackageAnnotationTypeName() nullMarkedPackageAnnotationTypeName}: <a href="https://jspecify.dev/">JSpecify</a> {@code @NullMarked}
     * <li>{@link CodeGenConfig#nonEmptyTypeName() nonEmptyTypeName}: {@value Builder#DEFAULT_NON_EMPTY_TYPE_NAME}
     * <li>{@link CodeGenConfig#childTypeAsTopLevel() childTypeAsTopLevel}: {@link ChildTypeAsTopLevel#AS_NEEDED AS_NEEDED}
     * <li>{@link CodeGenConfig#typedNodeSuperinterface() typedNodeSuperinterface}: none
     * <li>{@link CodeGenConfig#nameGenerator() nameGenerator}: {@link NameGenerator.DefaultNameGenerator}
     * <li>{@link CodeGenConfig#generateFindNodesMethods() generateFindNodesMethods}: true
     * <li>{@link CodeGenConfig#typedQueryNameGenerator() typedQueryNameGenerator}: none (that means no 'typed query' code is generated)
     * <li>{@link CodeGenConfig#customMethodsProvider() customMethodsProvider}: none
     * <li>{@link CodeGenConfig#generatedAnnotationConfig() generatedAnnotationConfig}: Javax {@link Generated @Generated}, using the current time (when code generation is performed) as 'generation time'
     * </ul>
     */
    @SuppressWarnings("OptionalUsedAsFieldOrParameterType")
    public static class Builder {
        private final String packageName;

        private Builder(String packageName) {
            this.packageName = packageName;
        }

        private Optional<TypeName> nullableAnnotationTypeName = Optional.of(TypeName.JSPECIFY_NULLABLE_ANNOTATION);
        private Optional<TypeName> nullMarkedPackageAnnotationTypeName = Optional.of(TypeName.JSPECIFY_NULLMARKED_ANNOTATION);

        /**
         * Use {@link Optional} instead of {@code @Nullable} in the generated code.
         *
         * @see CodeGenConfig#nullableAnnotationTypeName()
         */
        public Builder usingOptional() {
            nullableAnnotationTypeName = Optional.empty();
            nullMarkedPackageAnnotationTypeName = Optional.empty();
            return this;
        }

        /**
         * @see CodeGenConfig#nullableAnnotationTypeName()
         * @see CodeGenConfig#nullMarkedPackageAnnotationTypeName()
         */
        public Builder usingNullable(TypeName nullableAnnotationTypeName, TypeName nullMarkedPackageAnnotationTypeName) {
            this.nullableAnnotationTypeName = Optional.of(nullableAnnotationTypeName);
            this.nullMarkedPackageAnnotationTypeName = Optional.of(nullMarkedPackageAnnotationTypeName);
            return this;
        }

        /**
         * @see CodeGenConfig#nullableAnnotationTypeName()
         */
        public Builder usingNullable(TypeName nullableAnnotationTypeName) {
            this.nullableAnnotationTypeName = Optional.of(nullableAnnotationTypeName);
            this.nullMarkedPackageAnnotationTypeName = Optional.empty();
            return this;
        }

        private static final String DEFAULT_NON_EMPTY_TYPE_NAME = "NonEmpty";
        private String nonEmptyTypeName = DEFAULT_NON_EMPTY_TYPE_NAME;

        /**
         * @see CodeGenConfig#nonEmptyTypeName()
         */
        public Builder nonEmptyTypeName(String nonEmptyTypeName) {
            this.nonEmptyTypeName = Objects.requireNonNull(nonEmptyTypeName);
            return this;
        }

        private ChildTypeAsTopLevel childTypeAsTopLevel = ChildTypeAsTopLevel.AS_NEEDED;

        /**
         * @see CodeGenConfig#childTypeAsTopLevel()
         */
        public Builder childTypeAsTopLevel(ChildTypeAsTopLevel childTypeAsTopLevel) {
            this.childTypeAsTopLevel = Objects.requireNonNull(childTypeAsTopLevel);
            return this;
        }

        private Optional<TypeName> typedNodeSuperinterface = Optional.empty();

        /**
         * @see CodeGenConfig#typedNodeSuperinterface()
         */
        public Builder typedNodeSuperinterface(TypeName typedNodeSuperinterface) {
            this.typedNodeSuperinterface = Optional.of(typedNodeSuperinterface);
            return this;
        }

        // Visible for testing
        static final NameGenerator DEFAULT_NAME_GENERATOR = new NameGenerator.DefaultNameGenerator(NameGenerator.TokenNameGenerator.AUTOMATIC);
        private NameGenerator nameGenerator = DEFAULT_NAME_GENERATOR;

        /**
         * @see CodeGenConfig#nameGenerator()
         */
        public Builder nameGenerator(NameGenerator nameGenerator) {
            this.nameGenerator = Objects.requireNonNull(nameGenerator);
            return this;
        }

        private boolean generateFindNodesMethods = true;

        /**
         * @see CodeGenConfig#generateFindNodesMethods()
         */
        public Builder generateFindNodesMethods(boolean generateFindNodesMethods) {
            this.generateFindNodesMethods = generateFindNodesMethods;
            return this;
        }

        private Optional<TypedQueryNameGenerator> typedQueryNameGenerator = Optional.empty();

        /**
         * @see CodeGenConfig#typedQueryNameGenerator()
         */
        public Builder typedQueryNameGenerator(TypedQueryNameGenerator typedQueryNameGenerator) {
            this.typedQueryNameGenerator = Optional.of(typedQueryNameGenerator);
            return this;
        }

        private Optional<CustomMethodsProvider> customMethodsProvider = Optional.empty();

        /**
         * @see CodeGenConfig#customMethodsProvider()
         */
        public Builder customMethodsProvider(CustomMethodsProvider customMethodsProvider) {
            this.customMethodsProvider = Optional.of(customMethodsProvider);
            return this;
        }

        private Optional<GeneratedAnnotationConfig> generatedAnnotationConfig = Optional.of(new GeneratedAnnotationConfig(
            GeneratedAnnotationConfig.GeneratedAnnotationType.JAVAX_GENERATED,
            Optional.empty(),
            Optional.empty()
        ));

        /**
         * @see CodeGenConfig#generatedAnnotationConfig()
         */
        public Builder generatedAnnotationConfig(GeneratedAnnotationConfig generatedAnnotationConfig) {
            this.generatedAnnotationConfig = Optional.of(generatedAnnotationConfig);
            return this;
        }

        /**
         * Do not add a {@code @Generated} annotation to the generated code.
         *
         * @see CodeGenConfig#generatedAnnotationConfig()
         */
        public Builder withoutGeneratedAnnotation() {
            this.generatedAnnotationConfig = Optional.empty();
            return this;
        }

        /**
         * Applies the consumer to this builder and afterwards returns this builder.
         *
         * <p>This allows using a separate method to apply configuration, without interrupting the method call chain.
         */
        public Builder apply(Consumer<? super Builder> consumer) {
            consumer.accept(this);
            return this;
        }

        public CodeGenConfig build() {
            return new CodeGenConfig(
                packageName,
                nullableAnnotationTypeName,
                nullMarkedPackageAnnotationTypeName,
                nonEmptyTypeName,
                childTypeAsTopLevel,
                typedNodeSuperinterface,
                nameGenerator,
                generateFindNodesMethods,
                typedQueryNameGenerator,
                customMethodsProvider,
                generatedAnnotationConfig
            );
        }
    }

    /**
     * Whether to generate a top-level or a nested Java class for a node child type.
     *
     * <p>This is relevant when a node type can have itself as child. If a nested interface is
     * used, the compiler might reject the code due to cyclic inheritance, e.g.:
     * {@snippet lang=java :
     * class MyNode implements MyNode.Children {
     *     interface Children {}
     * }
     * }
     */
    public enum ChildTypeAsTopLevel {
        /**
         * Never generate top-level Java classes for node child types, instead always generate nested Java classes for them.
         *
         * <p><b>Warning:</b> This can lead to "cyclic inheritance" compilation errors.
         */
        NEVER,
        /**
         * Always generate top-level Java classes for node child types.
         */
        ALWAYS,
        /**
         * Generate top-level Java classes for node child types as needed, to avoid "cyclic inheritance" compilation errors.
         * If not needed for a specific node child type, generate a nested Java class instead.
         */
        AS_NEEDED
    }

    /*
     * Note: `@Generated` is in the `javax.annotation.processing` package, which is actually for annotation processing,
     * but maybe it is fine nonetheless to use the annotation, even though code generation here is not doing annotation
     * processing
     */
    /**
     * Configuration for the {@code @Generated} annotation placed on the code.
     *
     * @param annotationType
     *      information about the annotation type, such as qualified type name and annotation element names
     * @param generationTime
     *      fixed time when the code was generated, useful for reproducible builds; if empty the current time when
     *      code generation is performed is used
     * @param additionalInformation
     *      additional information to include in the {@code @Generated} annotation, can for example be the origin / version
     *      of the {@code node-types.json} file
     */
    public record GeneratedAnnotationConfig(GeneratedAnnotationType annotationType, Optional<Instant> generationTime, Optional<String> additionalInformation) {
        public GeneratedAnnotationConfig {
            Objects.requireNonNull(annotationType);
            Objects.requireNonNull(generationTime);
            Objects.requireNonNull(additionalInformation);

            if (annotationType.dateElementName().isEmpty() && generationTime.isPresent()) {
                throw new IllegalArgumentException("Cannot specify generationTime when annotation type has no date element");
            }
            if (annotationType.commentsElementName().isEmpty() && additionalInformation.isPresent()) {
                throw new IllegalArgumentException("Cannot specify additionalInformation when annotation type has no comments element");
            }
        }

        /**
         * Information about the annotation type to place on generated classes. {@link #JAVAX_GENERATED} can be used
         * in most cases, unless you want to specify a custom one.
         *
         * @param typeName
         *      qualified name of the annotation type, for example {@code com.example.Generated}
         * @param generatorElementName
         *      name of annotation type element of type {@code String} for storing the qualified name of the code
         *      generator; empty if not supported by this annotation type
         * @param dateElementName
         *      name of annotation type element of type {@code String} for storing the date when the code was
         *      generated; empty if not supported by this annotation type
         * @param commentsElementName
         *      name of annotation type element of type {@code String} for storing additional comments in the
         *      annotation; empty if not supported by this annotation type
         */
        // For use case of custom `@Generated`, see https://github.com/projectlombok/lombok/issues/1014
        public record GeneratedAnnotationType(TypeName typeName, Optional<String> generatorElementName, Optional<String> dateElementName, Optional<String> commentsElementName) {
            public GeneratedAnnotationType {
                Objects.requireNonNull(typeName);
                Objects.requireNonNull(generatorElementName);
                Objects.requireNonNull(dateElementName);
                Objects.requireNonNull(commentsElementName);
            }

            /**
             * Type {@link Generated javax.annotation.processing.Generated}
             */
            public static final GeneratedAnnotationType JAVAX_GENERATED = new GeneratedAnnotationType(TypeName.fromClass(Generated.class), Optional.of("value"), Optional.of("date"), Optional.of("comments"));
        }
    }

    private static String validateTypeName(String name) {
        JavaNameValidator.checkTypeName(name, false);
        return name;
    }

    private static String validateMemberName(String name) {
        JavaNameValidator.checkMemberName(name);
        return name;
    }

    /**
     * Wraps a name generator in a generator which validates that the generated names are valid Java names.
     */
    // Visible for testing
    static NameGenerator validatingNameGenerator(NameGenerator nameGenerator) {
        Objects.requireNonNull(nameGenerator);

        // Dedicated record class to have useful `toString` and `equals`
        record ValidatingNameGenerator(NameGenerator nameGenerator) implements NameGenerator {
            @Override
            public String generateJavaTypeName(String typeName) {
                return validateTypeName(nameGenerator.generateJavaTypeName(typeName));
            }

            @Override
            public String generateTypeNameConstant(String typeName) {
                return validateMemberName(nameGenerator.generateTypeNameConstant(typeName));
            }

            @Override
            public String generateTypeIdConstant(String typeName) {
                return validateMemberName(nameGenerator.generateTypeIdConstant(typeName));
            }

            @Override
            public String generateChildrenTypesName(String parentTypeName, List<String> childrenTypesNames) {
                return validateTypeName(nameGenerator.generateChildrenTypesName(parentTypeName, childrenTypesNames));
            }

            @Override
            public String generateChildrenTokenTypeName(String parentTypeName, List<String> tokenChildrenTypesNames) {
                return validateTypeName(nameGenerator.generateChildrenTokenTypeName(parentTypeName, tokenChildrenTypesNames));
            }

            @Override
            public String generateChildrenTokenName(String parentTypeName, String tokenType, int index) {
                return validateMemberName(nameGenerator.generateChildrenTokenName(parentTypeName, tokenType, index));
            }

            @Override
            public String generateChildrenGetterName(String parentTypeName, List<String> childrenTypesNames, boolean multiple, boolean required) {
                return validateMemberName(nameGenerator.generateChildrenGetterName(parentTypeName, childrenTypesNames, multiple, required));
            }

            @Override
            public String generateFieldNameConstant(String parentTypeName, String fieldName) {
                return validateMemberName(nameGenerator.generateFieldNameConstant(parentTypeName, fieldName));
            }

            @Override
            public String generateFieldIdConstant(String parentTypeName, String fieldName) {
                return validateMemberName(nameGenerator.generateFieldIdConstant(parentTypeName, fieldName));
            }

            @Override
            public String generateFieldTypesName(String parentTypeName, String fieldName) {
                return validateTypeName(nameGenerator.generateFieldTypesName(parentTypeName, fieldName));
            }

            @Override
            public String generateFieldTokenTypeName(String parentTypeName, String fieldName, List<String> tokenFieldTypesNames) {
                return validateTypeName(nameGenerator.generateFieldTokenTypeName(parentTypeName, fieldName, tokenFieldTypesNames));
            }

            @Override
            public String generateFieldTokenName(String parentTypeName, String fieldName, String tokenType, int index) {
                return validateMemberName(nameGenerator.generateFieldTokenName(parentTypeName, fieldName, tokenType, index));
            }

            @Override
            public String generateFieldGetterName(String parentTypeName, String fieldName, boolean multiple, boolean required) {
                return validateMemberName(nameGenerator.generateFieldGetterName(parentTypeName, fieldName, multiple, required));
            }

            @Override
            public Optional<String> generateNonNamedChildrenGetterName(String parentTypeName, boolean hasNamedChildren, boolean hasFields) {
                return nameGenerator.generateNonNamedChildrenGetterName(parentTypeName, hasNamedChildren, hasFields)
                    .map(CodeGenConfig::validateMemberName);
            }
        }

        return new ValidatingNameGenerator(nameGenerator);
    }

    /**
     * Wraps a name generator in a generator which validates that the generated names are valid Java names.
     */
    // Visible for testing
    static TypedQueryNameGenerator validatingTypedQueryNameGenerator(TypedQueryNameGenerator nameGenerator) {
        Objects.requireNonNull(nameGenerator);

        // Dedicated record class to have useful `toString` and `equals`
        record ValidatingTypedQueryNameGenerator(TypedQueryNameGenerator nameGenerator) implements TypedQueryNameGenerator {
            @Override
            public String generateBuilderClassName(String typeName) {
                return validateTypeName(nameGenerator.generateBuilderClassName(typeName));
            }

            @Override
            public String generateBuilderMethodName(String typeName) {
                return validateMemberName(nameGenerator.generateBuilderMethodName(typeName));
            }

            @Override
            public String generateAsSubtypeMethodName(String typeName, String supertypeName) {
                return validateMemberName(nameGenerator.generateAsSubtypeMethodName(typeName, supertypeName));
            }

            @Override
            public String generateWithFieldMethodName(String parentTypeName, String fieldName) {
                return validateMemberName(nameGenerator.generateWithFieldMethodName(parentTypeName, fieldName));
            }

            @Override
            public String generateWithoutFieldMethodName(String parentTypeName, String fieldName) {
                return validateMemberName(nameGenerator.generateWithoutFieldMethodName(parentTypeName, fieldName));
            }

            @Override
            public String generateFieldTokenMethodName(String parentTypeName, String fieldName, List<String> tokenFieldTypesNames) {
                return validateMemberName(nameGenerator.generateFieldTokenMethodName(parentTypeName, fieldName, tokenFieldTypesNames));
            }

            @Override
            public String generateChildTokenMethodName(String parentTypeName, List<String> tokenChildrenTypesNames) {
                return validateMemberName(nameGenerator.generateChildTokenMethodName(parentTypeName, tokenChildrenTypesNames));
            }
        }

        return new ValidatingTypedQueryNameGenerator(nameGenerator);
    }
}
